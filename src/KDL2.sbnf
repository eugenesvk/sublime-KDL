# too many bugs to finish, something fundamentally broken with
  # regex literals behave differently depending on whether you include them inline or as a rule
  # (rule)* is different from rule, rule:()*
  # number of pops weirdly wrong, either 2 instead of 1 or vice versa, but then when you fix one, some other rule combo breaks, so even with manual tweaks fails
  # can't have identical rules with different scopes depending on a prefix in complex situations (see composable1)
# todo: try children and if it works, leave as is?
# todo:
  # make children parseable instead of dumb
  # add slashdash context to elements
  # replace with lâ”â‹ (was bugged since it's an either|or rule)
# manual overrides: popâ†’2
  # child-tst1|0|nnn@1:
    # - meta_include_prototype: false
    # - match: '/-'
  # @{e-pv}
 # match: '[\r\n\x{C}\x{85}\x{2028}\x{2029}]' (or older lâ”â‹|0:
   # - match: '\n'
     # push: lâ”â‹|1
     # pop: 2

# Can't append scope, so for câ„-comments need to manually repeat all rules pending https://github.com/BenjaminSchaaf/sbnf/issues/42
# property check for true=1 not needed since true is already argument, so = will be marked illegal? otherwise jsut hngs recursively
# (?>\R) atomic groups are incompatible with the regex, test with 'syntax test regex comptibility'
# \k is unsupported with the new regex

main: (nnn); # nnn* masks illegal chars
nnn{n}:
 (câ„- n-name-câ„
 (composablecâ„)*
 (child-tst-câ„-)?
 # (câ„-? `{`{#[Sï½›]} (nnn)* `}`{#[Sï½]})?
 # (child )? # temp del
 # ((câ„- child-câ„-) | child )? # fails with ending ;; # of pops
   # â†‘requires manual adjustment of pop: trueâ†’2 @  scope: cchild.kdl2
   # f@ câ„-|2|nnn@2 branch point after match: '(?=/-)'
  node-terminator  # ';|\n'{#[Z] câ„}
  )
 |
 (    n-name
 (composable1)*
 (child-tst1)?
 # (câ„-? `{`{#[Sï½›]} (nnn)* `}`{#[Sï½]})?
 # (nnn )? # infinite loop
 # ((câ„- child-câ„-) | child )? # fails with ending ;; # of pops
   # â†‘requires manual adjustment of pop: trueâ†’2 @  scope: cchild.kdl2
   # f@ câ„-|2|nnn@2 branch point after match: '(?=/-)'
  node-terminator  # ';|\n'{#[Z] normal}
  )
;

child-tst1{}:(`/-`{xxx}? `{`{#[Sï½›]} (nnn)* `}`{#[Sï½] ï½});
child-tst-câ„-{#[SCâ„â€”ï½›] yyy}:child-tst1;
child-tst{}:(câ„-? `{`{#[Sï½›]} (nnn)* `}`{#[Sï½]});

tst-child:
 (    n-name
 (composable1)*
';|\n'{#[Z] normal})
;

# todo: Parse slash-dashed elements just like real ones, but append slashdash comment scope (avoids masking mistakes behind /-)
child{       }            	: child-outer                                                  	;
 child-outer{cho}         	:`{`{#[Sï½›]} (~child-inner    )* ~`}`{#[Sï½] #[SPTERM]         } 	;# } is an opt node part, mark it as node end
 child-inner{chi}         	:`{`{#[Sï½›]} (~child-inner    )* ~`}`{#[Sï½]                   } 	;# inner {} should just track opening/closing {}
child-câ„-{       #[SCâ„â€”ï½›]}	: child-outer-câ„-                                              	;
 child-outer-câ„-{#[SCâ„â€”ï½›]}	:`{`{#[Sï½›]} (~child-inner-câ„-)* ~`}`{#[Sï½] #[SPTERM]  #[Sâ„â€”ï½]} 	;# } is an opt node part, mark it as node end
 child-inner-câ„-{#[SCâ„â€”ï½›]}	:`{`{#[Sï½›]} (~child-inner-câ„-)* ~`}`{#[Sï½]                    }	;# inner {} should just track opening/closing {}

# composablecâ„{#[SCâ„â€”]}:composable1; # need to label endings separately to popâ†’2 more granularly
composable1{}: ( # -old-escseems to work with repeated and ending ;;;;, but then I can't set a separate scope for = vs !=
  # pâ€œâš¿â‚Œvâ€ | aâ€œargâ€
 (lâ”â‹*
  (((câ„-x lâ”â‹nonws*)? type?
    # (string ((pâ‚Œ type? data)		# 1 pâ€œâš¿â‚Œvâ€
    ((strâ€œâ€ | STR_RAW{#[S_M_S],1:#[SRR]        ,2:#[Sâ€œ]        ,3:#[Sâ€œ]        ,4:#[SRâ€œSâ€]        ,5:#[Sâ€]        ,6:#[Sâ€]        })
     ((pâ‚Œ type? data)                                  # 1 pâ€œâš¿â‚Œvâ€
      |                                      	Pâ‚ŒÂ¬)	# 2 aâ€œargâ€
    |KEYWORD{#[SM_ARG],1:#[SBOOL],2:#[SNULL]}	Pâ‚ŒÂ¬ 	# 3 a-keyword
    |argğŸ”¢                                    	Pâ‚ŒÂ¬ 		# 4 argğŸ”¢
    )           '(?=;|\n)'{Ã—e1}?)*           	#
  # yet â†“ for some reason works even when separated! â†‘ bugs when separated by '/-'
  |(câ„-y lâ”â‹*	pâš¿â‚Œvâ„-	'(?=;|\n)'{Ã—e2a}?)*	# 5 pâš¿â‚Œv
  |(         	pâš¿â‚Œv  	'(?=;|\n)'{Ã—e2b}?)*	#
  )*
));
composablecâ„{#[SCâ„â€”]}: ( # -old-escseems to work with repeated and ending ;;;;, but then I can't set a separate scope for = vs !=
  # pâ€œâš¿â‚Œvâ€ | aâ€œargâ€
 (lâ”â‹*
  (((câ„-x lâ”â‹nonws*)? type?
    # (string ((pâ‚Œ type? data)		# 1 pâ€œâš¿â‚Œvâ€
    ((strâ€œâ€ | STR_RAW{#[S_M_S],1:#[SRR]        ,2:#[Sâ€œ]        ,3:#[Sâ€œ]        ,4:#[SRâ€œSâ€]        ,5:#[Sâ€]        ,6:#[Sâ€]        })
     ((pâ‚Œ type? data)                                  # 1 pâ€œâš¿â‚Œvâ€
      |                                      	Pâ‚ŒÂ¬)	# 2 aâ€œargâ€
    |KEYWORD{#[SM_ARG],1:#[SBOOL],2:#[SNULL]}	Pâ‚ŒÂ¬ 	# 3 a-keyword
    |argğŸ”¢                                    	Pâ‚ŒÂ¬ 		# 4 argğŸ”¢
    )           '(?=;|\n)'{Ã—e1â„}?)*          	#
  # yet â†“ for some reason works even when separated! â†‘ bugs when separated by '/-'
  |(câ„-y lâ”â‹*	pâš¿â‚Œvâ„-	'(?=;|\n)'{Ã—e2aâ„}?)*	# 5 pâš¿â‚Œv
  |(         	pâš¿â‚Œv  	'(?=;|\n)'{Ã—e2bâ„}?)*	#
  )*
));
# lâ”â‹nonws
câ„-x{xcom}:câ„-;
câ„-y{ycom}:câ„-;
composable-lineesc{}: ( # "proper" line escape, but can't fix some pop errors by changing to 2
  # pâ€œâš¿â‚Œvâ€ | aâ€œargâ€
 (lâ”â‹*
  ((câ„- lâ”â‹*)? type?
    # (string ((pâ‚Œ type? data)		# 1 pâ€œâš¿â‚Œvâ€
    ((strâ€œâ€ | STR_RAW{#[S_M_S],1:#[SRR]        ,2:#[Sâ€œ]        ,3:#[Sâ€œ]        ,4:#[SRâ€œSâ€]        ,5:#[Sâ€]        ,6:#[Sâ€]        })
     ((pâ‚Œ type? data)                                  # 1 pâ€œâš¿â‚Œvâ€
      |                                      	Pâ‚ŒÂ¬)	# 2 aâ€œargâ€
    |KEYWORD{#[SM_ARG],1:#[SBOOL],2:#[SNULL]}	Pâ‚ŒÂ¬ 	# 3 a-keyword
    |argğŸ”¢                                    	Pâ‚ŒÂ¬ 		# 4 argğŸ”¢
    )           '(?=;|\n)'?)*                	#
  # yet â†“ for some reason works even when separated! â†‘ bugs when separated by '/-'
  |(câ„- pâš¿â‚Œvâ„-	'(?=;|\n)'?)*	# 5 pâš¿â‚Œv
  |(    pâš¿â‚Œv  	'(?=;|\n)'?)*	#
));
composable11{}: ( # test
 ('(\\)'{1:#[Sâ¯»â”]} '[[^\\]&&[\S]]'{#[SğŸ›‘]}? lâ”âˆ…â„â„? expâ¤)*
  (('#[Câ„â€”]'{#[Sâ„â€”] X}?	argğŸ”¢  	'(?=;|\n)'?)*
  |('#[Câ„â€”]'{#[Sâ„â€”] Y}?	pâš¿â‚Œvâ„-	'(?=;|\n)'?)*
));

nnn-some-progress-but-c{n}: câ„-? n-name
(
   ( (câ„- ((
      (pâ€œâš¿â‚Œvâ€â„-        	      )     	#
    |(type     ? aâ€œvalâ€	Pâ‚ŒÂ¬ '(?=;)')	# todo remove when bug is fixed
   ))
   )* )
  |
  ( ( ((
    (pâ€œâš¿â‚Œvâ€            	      )     	#
    |(type     ? aâ€œvalâ€	Pâ‚ŒÂ¬ '(?=;)')	# todo remove when bug is fixed
    |(pâš¿â‚Œv             	      )     	#
    |(type     ? argğŸ”¢  	Pâ‚ŒÂ¬)        	#
   ))*
   ) )
)*
';|\n'{#[Z]} ;

nnn3{n}: câ„-? n-name # 'n+|a+|r?"a+|n+"'{#[Z] ğŸ†”}
(
#   ( (câ„- ((
#      (pâ€œâš¿â‚Œvâ€â„-        	      )	#
#    | (typeâ„-? aâ€œvalâ€â„-	Pâ‚ŒÂ¬)   	#
#    | (pâš¿â‚Œvâ„-          	      )	#
#    | (typeâ„-? argğŸ”¢â„-  	Pâ‚ŒÂ¬)   	#
#   ))
#   )* )
#  |
  ( ( ((
    (pâ€œâš¿â‚Œvâ€            	      )	#
    |(type     ? aâ€œvalâ€	Pâ‚ŒÂ¬)   	#
    |(pâš¿â‚Œv             	      )	#
    |(type     ? argğŸ”¢  	Pâ‚ŒÂ¬)   	#
   ))
   )* )
)*
';|\n'{#[Z]} ;



nnn1{n}: câ„-? n-name (node-tests)* n-end ;
node-tests:
   ( (câ„- ((
      (pâ€œâš¿â‚Œvâ€â„-        	      )	#
    | (typeâ„-? aâ€œvalâ€â„-	Pâ‚ŒÂ¬)   	#
    | (pâš¿â‚Œvâ„-          	      )	#
    | (typeâ„-? argğŸ”¢â„-  	Pâ‚ŒÂ¬)   	#
   ))*                 	       	# NO* breaks repeat "a" /-"a"=1 /-"a"=1
   el-end)* )
  |( ( ((
     (pâ€œâš¿â‚Œvâ€           	      )	#
    |(           aâ€œvalâ€	Pâ‚ŒÂ¬)   	# fixes â†“, but add a (a)"1"; â†ğŸ›‘
    |(type     ? aâ€œvalâ€	Pâ‚ŒÂ¬)   	# a (a)1; â†ğŸ›‘
    |(pâš¿â‚Œv             	      )	#
    |(type     ? argğŸ”¢  	Pâ‚ŒÂ¬)   	#
   ))*                 	       	# * breaks "a" "a" ;â†ğŸ›‘
   el-end)* )
;
  # |( (	(    pâ€œâš¿â‚Œvâ€	|    type     ? NEXTâ€œ aâ€œvalâ€	Pâ‚ŒÂ¬	#
  # single line with repeatable mix of two elements
  # "a" /-"a"=1  /-"a"=1 /-"a" /-"a"=1;
  # |( câ„-( (	(    pâ€œâš¿â‚Œvâ€â„-	|    typeâ„-? aâ€œvalâ€â„-	Pâ‚ŒÂ¬) 	el-end))* ) #works
  # |( ( câ„- 	(    pâ€œâš¿â‚Œvâ€â„-	|    typeâ„-? aâ€œvalâ€â„-	Pâ‚ŒÂ¬)*	el-end)* ) # works
  # |( ( (   	(câ„- pâ€œâš¿â‚Œvâ€â„-	|câ„- typeâ„-? aâ€œvalâ€â„-	Pâ‚ŒÂ¬) 	el-end))* ) # works
  # |( ( (câ„-	(    pâ€œâš¿â‚Œvâ€â„-	|    typeâ„-? aâ€œvalâ€â„-	Pâ‚ŒÂ¬) 	el-end))* ) #fails

  # |( ( (câ„- pâ€œâš¿â‚Œvâ€â„- )*     	el-end)* )
  # |( ( (câ„- typeâ„-? aâ€œvalâ€â„-	Pâ‚ŒÂ¬)*	el-end)* )

  # |( ( (câ„-	(pâ€œâš¿â‚Œvâ€â„-	| typeâ„-? aâ€œvalâ€â„- 	Pâ‚ŒÂ¬)	el-end))* )
  # |( (     	(pâ€œâš¿â‚Œvâ€  	| type     ? aâ€œvalâ€	Pâ‚ŒÂ¬)	el-end )* )
  # |( ( (câ„-	(pâš¿â‚Œvâ„-  	| typeâ„-? argğŸ”¢â„-   	Pâ‚ŒÂ¬)	el-end))* )
  # |( (     	(pâš¿â‚Œv    	| type     ? argğŸ”¢  	Pâ‚ŒÂ¬)	el-end )* )

  # |( (	(câ„- (pâš¿â‚Œvâ„-	|pâ€œâš¿â‚Œvâ€â„-)	      )	el-end )* )

  # |( (	(câ„- pâ€œâš¿â‚Œvâ€â„-	                      	      )	el-end )* )
  # |( (	(câ„- pâ€œâš¿â‚Œvâ€â„-	                      	      )	el-end )* )
  # |( (	(    pâ€œâš¿â‚Œvâ€  	                      	      )	el-end )* )
  # |( (	(    pâš¿â‚Œv    	                      	      )	el-end )* )
  # |( (	(            	     type     ? aâ€œvalâ€	Pâ‚ŒÂ¬)   	el-end )* )
  # |( (	(            	     type     ? argğŸ”¢  	Pâ‚ŒÂ¬)   	el-end )* )
  # |( (	(            	 câ„- typeâ„-? aâ€œvalâ€â„- 	Pâ‚ŒÂ¬)   	el-end )* )
  # |( (	(            	 câ„- typeâ„-? argğŸ”¢â„-   	Pâ‚ŒÂ¬)   	el-end )* )


# Meta clauses
EXTENSIONS = 'KDL2' # space-separated list of file extensions = `file_extensions` @sublime-syntax

# Rules
#name[par]{opt}	: expr                                                         	;
# prototype{}  	: (~(nodebâ |comment))*                                         	;#
prototype{}    	: (~comment)*                                                  	;#(~bâ  | comment )*	;# lineâ  OR comment TODO: add nâ  including bâ  selects too much, might need to manually fix it in every scope
 comment{}     	: câ„line | câ„âˆ—blockğŸ—˜doc                                        	;# |câ„-element
mmain{}        	: nodes                                                        	;# (~any)* masks illegal chars
 # nodes{}     	: node n-child?                                                	;# â‰  lineâ * (node nodes?)? lineâ * (lineâ  is @prototype)
 #any{}        	: punctuation  | number | string | operator | identifier       	;
 keyword{}     	: bool | null                                                  	;
 data{}        	: bool | null | string | number                                	;# 4 Data Types
 #identifier{} 	: keyword | param | ident-other                                	;
 #number{}     	: number-float | number-int                                    	;
 #punctuation{}	: dot | comma  | semi | parens | brackets | braces             	;
 #operator{}   	: operator-cast | operator-star | operator-tilde | operator-any	;
 #param{}      	: param-ordinal | param-named                                  	;
 #atom{}       	: number | string | ident-other                                	;

# todo: add câ„-element
# todo: add back câ„- children

# main          	: câ„-nodes; #nodes |
   # nodes{ns}  	:    node n-end;#(   n-child)?                                                               	;#
   nodes{}      	:    n-name ('n-child'      )? (n-argâˆ¨prop  )* n-end ;#'(;)|(\n)'{1:#[SPTERM]};#(   n-child)?	;#
# câ„-nodes{c-ns}	: câ„- n-name-câ„ ('n-child-blank')? (n-argâˆ¨propâ„-)* n-end ;#(n-child-blank)?                  	;#

# câ„-nodes{c-ns}	: câ„-node (n-child-blank)? n-end 	;#bug â†“
   # nodes      	:    node (n-child       )? n-end	;#bug â†“
    # node{n}   	:    n-name (   n-argâˆ¨prop)*     	;#bugs when added as a rule
 # câ„-node{c-n} 	: câ„- n-name-câ„ (n-argâˆ¨propâ„-)*  	;#bugs when added as a rule
 n-name-câ„{}    	: nâ ? type? nodeğŸ†”â„-              	;#â‰ˆ (/- node-space*)? type? identifier
 n-name{}       	: nâ ? type? nodeğŸ†”                	;# !!!chld todo nodeğŸ†” hangs, likely again due to bool/null repeat

# câ„-nodes{c-ns}: n-name (câ„- pâ€œâš¿â‚Œvâ€ | câ„- pâš¿â‚Œv) * (n-argâˆ¨propâ„-)* n-end ;
 n-argâˆ¨prop           	:(câ„- pâ€œâš¿â‚Œvâ€ |  câ„- pâš¿â‚Œv)| (pâ€œâš¿â‚Œvâ€ | pâš¿â‚Œv | argument)	;# â‰  (node-space+ node-prop-or-arg)*  TODO: moving * here bugs for some reason
 n-argâˆ¨propâ„-{cnarg}  	:(câ„- pâ€œâš¿â‚Œvâ€ |  câ„- pâš¿â‚Œv |  pâ€œâš¿â‚Œvâ€ | pâš¿â‚Œv | argument)	;
câ„-argâˆ¨prop    {sl}   	:(câ„- pâ€œâš¿â‚Œvâ€)| (câ„- pâš¿â‚Œv)                            	;# some order sensitivity issues, args first deals with invalid keywords better by tagging them as args always and making = illegal
   argâˆ¨propâ„-{in}     	:    (pâ€œâš¿â‚Œvâ€ | pâš¿â‚Œv)                                 	;# regular argprops inside a câ„-node
   argâˆ¨prop           	:    (pâ€œâš¿â‚Œvâ€ | pâš¿â‚Œv | argument  )                    	;
   # argâˆ¨prop         	:     (argument      | prop-kâ‚Œv   )                  	;
   #                  	  nâ ? (câ„-argâˆ¨prop | argâˆ¨prop)                       	;# todo del
n-child{      #[SMAP]}	:`{`{#[Sï½›]} nodes*    `}`{#[Sï½]}                     	;# â‰  (node-space* node-children ws*)?  node-children = (/- node-space*)? { nodes }
n-child-blank{#[SMAP]}	:`{`{#[Sï½›]} ~ `}`{#[Sï½]}                             	;
n-end{}               	: node-terminator                                    	;# â‰  node-space* node-terminator
 # n-child            	: (node-children           nâ ?)                      	;# â‰  (node-space* node-children ws*)?
             # (       nâ * node-children bâ câ„âˆ—)? # (node-space* node-children ws*)?

nodeğŸ†”{  #[SğŸ†”ğŸ”–]node        }	: uğŸ†”-n	;# todo: bug scope bleeds
nodeğŸ†”â„-{#[SğŸ†”ğŸ”–]node #[SCâ„â€”]}	: uğŸ†”â„-	;

# node-children{#[SMAP]}	:`{`{#[Sï½›]} n-name (n-argâˆ¨prop)* n-end     	node-children `}`{#[Sï½]}	;# â‰ˆ (/- node-space*)? { nodes }
# node-children{#[SMAP]}	: câ„-child |`{`{#[Sï½›]}nodes`}`{#[Sï½]}      	;# â‰ˆ (/- node-space*)? { nodes }
# câ„-element1           	: câ„- (câ„-child | argumentâ„- | prop-kâ‚Œvâ„-)?	;# slash-dash       nâ *
 # câ„-node {#[SCâ„â€”]}    	:'#[Câ„â€”]'{#[Sâ„â€”]}                          	;# TODO


# arg/prop order affects whether children comments work or
# n1ode-argâˆ¨prop  	: (câ„- '' argumentâ„- | câ„-2b prop-kâ‚Œvâ„- | argument | prop-kâ‚Œv)  	;# â‰ ('/-' node-space*)? (prop | p-value) â€¹Recursion risk
# node-argâˆ¨prop{t}	: (câ„- (argumentâ„- | prop-kâ‚Œvâ„-)) | (argument | prop-kâ‚Œv)       	;# â‰ ('/-' node-space*)? (prop | p-value) â€¹Recursion risk
# node-argâˆ¨prop{t}	: (câ„- childÂ¬ (argumentâ„- | prop-kâ‚Œvâ„-)) | (argument | prop-kâ‚Œv)	;# â‰ ('/-' node-space*)? (prop | p-value) â€¹Recursion risk
  # câ„-{#[SCâ„â€”]}  	:'#[Câ„â€”]'{#[Sâ„â€”]}                                               	;


# bareğŸ†”           : keywordÂ¬ | bareğŸ†”âˆ¨keyword  ;# â‰bare-identifier = ((identifier-char - digit - sign) identifier-char* | sign ((identifier-char - digit) identifier-char*)?) - keyword
 # bareğŸ†”âˆ¨keyword  :'#[BAREğŸ†”âˆ’Â±]' | '#[BAREğŸ†”Â±]' ;
 # BAREğŸ†”          ='#[BAREğŸ†”âˆ’Â±]|#[BAREğŸ†”Â±]'            #
  # BAREğŸ†”âˆ’Â±       =     '(#[CHARğŸ†”âˆ’DIGÂ±])(#[CHARğŸ†”])*'   #
  # BAREğŸ†”Â±        ='#[Â±]((#[CHARğŸ†”âˆ’DIG])(#[CHARğŸ†”])*)?'  #
# uğŸ†”â„-           : stringâ„-   | bareğŸ†”â„-      ;#todo temporary disable bool/null


_ST='Type'
 # bug: can't use a rule with multiple conditions,
type{  #[SMğŸ”–]}          	: `(`{#[Sâ¯»ğŸ”–]begin        } tğŸ†”   `)`{#[Sâ¯»ğŸ”–]end        }	;
typeâ„-{#[SMğŸ”–]}          	: `(`{#[Sâ¯»ğŸ”–]begin #[SCâ„â€”]} tğŸ†”â„- `)`{#[Sâ¯»ğŸ”–]end #[SCâ„â€”]}	;
 tğŸ†”{#[SğŸ†”]type}          	:     uğŸ†”                                              	;
 tğŸ†”â„-{#[SğŸ†”]type #[SCâ„â€”]}	:     uğŸ†”â„-                                            	;
# type{#[SMğŸ”–]}          	: tâ€¹    tğŸ†”     tâ€º                                     	;
#  tğŸ†”{#[SğŸ†”]type}        	:     uğŸ†”                                              	;
 tâ€¹{ }                  	: `(`                  {#[Sâ¯»ğŸ”–]begin}                  	;#todo bug as a rule
 tâ€º{  }                 	:                `)`   {#[Sâ¯»ğŸ”–]end  }                  	;#todo bug as a rule
# typeâ„-{#[SMğŸ”–]}        	: tâ€¹â„- tğŸ†”â„- tâ€ºâ„-                                      	; #[SCâ„â€”]
 tâ€¹â„-{}                 	: `(`                  {#[Sâ¯»ğŸ”–]begin #[SCâ„â€”]}          	;#todo bug as a rule
 tâ€ºâ„-{}                 	:                `)`   {#[Sâ¯»ğŸ”–]end   #[SCâ„â€”]}          	;#todo bug as a rule
# |(`(`{#[Sâ¯»ğŸ”–]begin} sstr-raw `)`{#[Sâ¯»ğŸ”–]end}) # todo: use str-raw with more literal if bugs
type-arg{   #[SM_ARG]         }	:type;
type-argâ„-{ #[SM_ARG]  #[SCâ„â€”]}	:type;
type-prop{  #[SM_PROP]        }	:type;
type-propâ„-{#[SM_PROP] #[SCâ„â€”]}	:type;


node-argâˆ¨prop{t}        	: (câ„- '' nâ * câ„-elem) | (argument | prop-kâ‚Œv)                 	;# â‰ ('/-' node-space*)? (prop | p-value) â€¹Recursion risk
câ„-elem{tc}             	: (câ„-child-outer | argumentâ„- | prop-kâ‚Œvâ„-)                   	;
# node-argâˆ¨prop{t}      	: (câ„-childÂ¬ (argumentâ„- | prop-kâ‚Œvâ„-)) | (argument | prop-kâ‚Œv)	;# â‰ ('/-' node-space*)? (prop | p-value) â€¹Recursion risk
 # câ„-childÂ¬{#[SCâ„â€”]}   	: '#[Câ„â€”](?!\{)'{#[Sâ„â€”]}                                       	;# todo: partically works, but this doesn't exclude nâ 
 câ„-childÂ¬{#[SCâ„â€”] noch}	: '#[Câ„â€”]'{a} '(?!\{)'{b #[Sâ„â€”]} câ„-child?                     	;# todo: partically works, but this doesn't exclude nâ 

 # câ„-childÂ¬{#[SCâ„â€”] noch}	: '#[Câ„â€”](?!\{)'{#[Sâ„â€”]} | '\{'{#[Sâ„â€”]} ~ '\}'{#[Z]}	;# todo: partically works, but this doesn't exclude nâ 


_SA='Argument'
# todo:
  # replace aâ€œargâ€ etc with proper composable, though even it bugs when used as a rule!!!
argument{    #[SM_ARG]}  	: type-arg  ? arg-value    Pâ‚ŒÂ¬ ;#POP	;# â‰ value=type? (string | number | keyword)
argumentâ„-{  #[SM_ARG]}  	: type-argâ„-? arg-valueâ„-  Pâ‚ŒÂ¬ ;#POP	;# SCâ„â€” appended at lower levels since meta scopes only prepend
 # argğŸ”¢{      #[SM_ARG]} 	:(type-arg  ? number     Pâ‚ŒÂ¬)       	;
 # argğŸ”¢â„-{    #[SM_ARG]} 	:(type-argâ„-? numberâ„-   Pâ‚ŒÂ¬)       	;
 # a-keyword{  #[SM_ARG]}	:(type-arg  ? KEYWORD{1:#[SBOOL]        ,2:#[SNULL]        } Pâ‚ŒÂ¬);
 # a-keywordâ„-{#[SM_ARG]}	:(type-argâ„-? KEYWORD{1:#[SBOOL] #[SCâ„â€”],2:#[SNULL] #[SCâ„â€”]} Pâ‚ŒÂ¬);
 aâ€œargâ€{     #[SM_ARG]}  	: type-arg  ?         	 # todo: sometimes bugs without POP_END
  (                      	  STR{#[S_M_S]        	 ,1:#[SRR],2:#[Sâ€œ],3:#[Sâ€œ],4:#[SRâ€œSâ€]        ,5:#[Sâ€],6:#[Sâ€], 7:#[Sâ€œ],8:#[Sâ€œSâ€]        ,9:#[Sâ€]}
  )                      	  Pâ‚ŒÂ¬                 	;
 aâ€œargâ€â„-{   #[SM_ARG]}  	: type-argâ„-?         	 # todo: sometimes bugs without POP_END
  (                      	  STR{#[S_M_S] #[SCâ„â€”]	 ,1:#[SRR],2:#[Sâ€œ],3:#[Sâ€œ],4:#[SRâ€œSâ€] #[SCâ„â€”],5:#[Sâ€],6:#[Sâ€], 7:#[Sâ€œ],8:#[Sâ€œSâ€] #[SCâ„â€”],9:#[Sâ€]}
  )                      	  Pâ‚ŒÂ¬                 	;

argument-ns{    #[SM_ARG]}  	: arg-value-ns    Pâ‚ŒÂ¬ ;
 arg-value-ns{}             	:(           a-keyword   | argğŸ”¢  )	;
 arg-value{}                	:(aâ€œvalâ€   | a-keyword   | argğŸ”¢  )	;#bugs as a composable rule
 arg-valueâ„-{}              	:(aâ€œvalâ€â„- | a-keywordâ„- | argğŸ”¢â„-)	;#bugs as a composable rule
  aâ€œvalâ€{    #[SM_ARG]}     	:(string  ) ;#'"[^"]*"(?!=)'      	;# todo: bugs without '' https://github.com/BenjaminSchaaf/sbnf/issues/39
  aâ€œvalâ€â„-{  #[SM_ARG]}     	:(stringâ„-) ;#'"[^"]*"(?!=)'      	;
  argğŸ”¢{   #[SM_ARG]}        	:(number  )                       	;
  argğŸ”¢â„-{ #[SM_ARG]}        	:(numberâ„-)                       	;
  a-keyword{    #[SM_ARG]}  	:(KEYWORD{1:#[SBOOL]        ,2:#[SNULL]        } );
  a-keywordâ„-{  #[SM_ARG]}  	:(KEYWORD{1:#[SBOOL] #[SCâ„â€”],2:#[SNULL] #[SCâ„â€”]} );
  # a-keyword{    #[SM_ARG]}	:(bool-arg   | null-arg  )	;# separated to allow '' in different places, othewise bugs
  # a-keywordâ„-{  #[SM_ARG]}	:(bool-argâ„- | null-argâ„-)	;
   bool-arg{    }           	:(bool  )                 	;# todo: bugs without '' https://github.com/BenjaminSchaaf/sbnf/issues/39
   bool-argâ„-{}             	:(boolâ„-)                 	;
   null-arg{    }           	:(null  )                 	;# todo: bugs without '' https://github.com/BenjaminSchaaf/sbnf/issues/39
   null-argâ„-{}             	:(nullâ„-)                 	;

_SP='Property'
# todo:
  # exclude bool/null from props
  # pâ€œâš¿â€ bugs when used as a rule
  # pâ‚Œ bugs when used as a rule https://github.com/BenjaminSchaaf/sbnf/issues/37
  # replace ruelâ„- with a reference to the main rule when scope appending is added
prop-kâ‚Œv{}                   	: pâ€œâš¿â‚Œvâ€   | pâš¿â‚Œv	; # propÂ¬kw check not needed since keywords are already parsed as arguments only (also recursive hang)
 pâ€œâš¿â‚Œvâ€{Pâ€}                  	:((STR{#[SMâš¿] #[S_M_S]        ,1:#[SRR],2:#[Sâ€œ],3:#[Sâ€œ],4:#[SRâ€œSâ€] #[Sâš¿]        ,5:#[Sâ€],6:#[Sâ€], 7:#[Sâ€œ],8:#[Sâ€œSâ€] #[Sâš¿]        ,9:#[Sâ€]})
  (                          	        Pâ‚Œ{#[SMâ‚Œ],1:#[SğŸ›‘],3:#[Sâ‚Œ],4:#[SğŸ›‘]} p-value) );
 pâš¿â‚Œv{}                      	:(BAREğŸ†”{#[SMâš¿] #[Sâš¿]} Pâ‚Œ{#[SMâ‚Œ],1:#[SğŸ›‘],3:#[Sâ‚Œ],4:#[SğŸ›‘]} p-value)  ; #'k  k=1' errors only 1st space
 # pâš¿â‚Œv{}                    	:(pâš¿   Pâ‚Œ{#[SMâ‚Œ],1:#[SğŸ›‘],3:#[Sâ‚Œ],4:#[SğŸ›‘]} p-value)  ; #'k  k=1' errors only 1st space
  # pâš¿{    #[SMâš¿] #[Sâš¿]}     	: BAREğŸ†”                	;#bugs when used as a rule in a rule
  p-value{#[SMâ‚ŒV]}           	  : type-prop?    data 	;# todo: meta scope bleeds into argâˆ¨prop keyâ‚Œ '='
 # propÂ¬kw{}                 	: propÂ¬bool | propÂ¬null	;
  # pâš¿bool{  #[SMâš¿] #[Sâš¿]}   	: bool                 	;#
  # pâš¿null{  #[SMâš¿] #[Sâš¿]}   	: null                 	;#
  # propÂ¬bool{}              	:(pâš¿bool   pâ‚ŒğŸ›‘ p-value)	;# match, but highlight = as illegal (todo: lookahead not supported)
  # propÂ¬null{}              	:(pâš¿null   pâ‚ŒğŸ›‘ p-value)	;# ... not sure how to force NOT matching to pass to args
prop-kâ‚Œvâ„-{}                 	: pâ€œâš¿â‚Œvâ€â„- | pâš¿â‚Œvâ„-    	;#
 pâ€œâš¿â‚Œvâ€â„-{}                  	:((STR{#[SMâš¿] #[S_M_S] #[SCâ„â€”],1:#[SRR],2:#[Sâ€œ],3:#[Sâ€œ],4:#[SRâ€œSâ€] #[Sâš¿] #[SCâ„â€”],5:#[Sâ€],6:#[Sâ€], 7:#[Sâ€œ],8:#[Sâ€œSâ€] #[Sâš¿] #[SCâ„â€”],9:#[Sâ€]})
  (                          	         Pâ‚Œ{#[SMâ‚Œ],1:#[SğŸ›‘],3:#[Sâ‚Œ] #[SCâ„â€”],4:#[SğŸ›‘]} p-valueâ„-) );
 pâš¿â‚Œvâ„-{}                    	:(BAREğŸ†”{#[SMâš¿] #[Sâš¿] #[SCâ„â€”]} pâ ï¹–ğŸ›‘ (pâ‚Œâ„- p-valueâ„-))	; #'k k=1' errors only first space
 # pâš¿â‚Œvâ„-{}                  	:(pâš¿â„- pâ ï¹–ğŸ›‘ ((pâ‚Œâ„- p-valueâ„-) | POP_S))             	; #'k k=1' errors only first space
  pâš¿â„-{ #[SMâš¿] #[Sâš¿] #[SCâ„â€”]}	: BAREğŸ†”                                             	;#
  p-valueâ„-{#[SMâ‚ŒV]}         	  : typeâ„-?  dataâ„-                                 	;
 # todo: move â†“ back when â†‘ todos are fixed and move scopes to append to clean existing data
 #pâ€œâš¿â‚Œvâ€{}            	:(pâ€œâš¿â€   pâ‚Œ p-value  )	;
 #pâ€œâš¿â‚Œvâ€â„-{}          	:(pâ€œâš¿â€â„- pâ‚Œ p-valueâ„-)	;
  pâ€œâš¿â€{  #[SMâš¿] #[Sâš¿]}	: string              	;
  pâ€œâš¿â€â„-{#[SMâš¿]      }	: stringâš¿             	;##[Sâš¿] #[SCâ„â€”]
_SH='Property helpers'
 # Pâ‚ŒL       	='(?<!\s)=(?!\s)'                     	# better match spaces as invalid to highlight key as key
 PROPâ ï¹–      	='(#[Bâ ])?'                           	#  todo '(?<!#[Bâ ])=(?!#[Bâ ])'
 Pâ‚ŒKW        	='(=)'                                	 # keyword check should ignore whitespace to avoid flashing 'true b'
 # Pâ‚ŒÂ¬       	='(#[Bâ ])*(?!=)'                      	# todo: del, this glues multiple args together, and not needed to mirror â†‘ for a â¸™
 Pâ‚ŒÂ¬         	='(?!=)'                              	#
 Pâ‚Œ          	='(#[Bâ ])?(#[Bâ ])*(=)(#[Bâ ])?(#[Bâ ])*'	# match 1st space make only it highlight red
 STRâ‚Œ        	='(r)(#*)(\")([^"]*)(\")(\k<2>)#[Pâ‚Œ]|(")([^"]*)(")#[Pâ‚Œ]'
 pâ‚Œ{  #[SMâ‚Œ]}	: Pâ‚Œ{1:#[SğŸ›‘],3:#[Sâ‚Œ]       ,4:#[SğŸ›‘]} 	;# TODO: bugs when used as a rule
 pâ‚Œâ„-{#[SMâ‚Œ]}	: Pâ‚Œ{1:#[SğŸ›‘],3:#[Sâ‚Œ] #[SCâ„â€”],4:#[SğŸ›‘]}	;#
 pâ‚ŒğŸ›‘{#[SMâ‚Œ]} 	: Pâ‚Œ{1:#[SğŸ›‘],3:#[Sâ‚Œ] #[SğŸ›‘],4:#[SğŸ›‘]}  	;
 pâ ï¹–ğŸ›‘{}      	: PROPâ ï¹–{1:#[SğŸ›‘]                 }   	;# TODO: bugs when used as a rule
 pâ‚ŒÂ¬{}       	: Pâ‚ŒÂ¬                                	;# helps differentiate key in property from argument

nâ {nâ }	: lâ”â‹ bâ *                         	;# todo check if expâ¤ is needed and check bsp is needed here del scope
#     	  expâ¤                            	;# â‰  ws* escline ws* | ws+
 #    	                                  	     ws handled via prototype comment, it does include single-lines, but that's not an issue sine it requires line ending, so wouldn't match anything in-between?
 #    	: bâ câ„âˆ—* lâ”â‹ bâ câ„âˆ—* | bâ câ„âˆ— bâ câ„âˆ—*	;#   ws = bom | uniâ  | multiline-com
 #    	:(bâ câ„âˆ— bâ câ„âˆ—* lâ”â‹? | lâ”â‹) bâ câ„âˆ—* 	;#   escline = \ ws* (comment-line | â¤)

 # lâ”â‹{}      	: `\`{#[Sâ¯»â”]} '#[PRECâ„â„Câ„âˆ—â¤]'{2:#[SğŸ›‘]}* lâ”âˆ…â„â„?	;# \ ws* (câ„line | â¤)
  # PRECâ„â„Câ„âˆ—â¤	='(?<=\\)( *)(.*?)((?=#[Câ„â„])|(?=#[Câ„âˆ—])|(?=\R))'   ## non-whitespace before the first comment start/â¤ (so non-greedy)
 # â†‘todo rewrite with a set to avoid lookarounds â†“
 lâ”â‹{}  :'(\\)'{1:#[Sâ¯»â”]} ('#[Bâ ]'|câ„âˆ—blockğŸ—˜doc|'\S'{#[SğŸ›‘]})* (câ„line|'#[Uâ¤S]')  lâ”âˆ…â„â„? ;
 # lâ”â‹{}           	: lâ”â‹blank | lâ”â‹nonws ;
  # lâ”â‹blank{blank}	:'(\\)'{1:#[Sâ¯»â”]} '[[^\\]&&[\S]]'{#[SğŸ›‘]}? lâ”âˆ…â„â„       ;
  lâ”â‹nonws{nonws}  	:'(\\)'{1:#[Sâ¯»â”]} '[[^\\]&&[\S]]'{#[SğŸ›‘]}? lâ”âˆ…â„â„? expâ¤;

# nâ {nâ }:`\`{#[Sâ¯»â”]} lâ”âˆ…â„â„?;

# â†“ fails with prototype (false doesn't help since it'll be part of the higher scope that will work on a newline)
# todo: check if it's possible to just match a block comment first alone on a line before prototype?
escline{include-prototype:false}:t0|t01;#|t4|t44|t1|t2|t3|t5|t6;
  t0:('(\\)(\n)'{t0, 1:#[Sâ¯»â”],2:#[SğŸ›‘]}  `/**/` ); #â† fails to match with a prototype, has lower priority
    # a\
    # /**/  â† this is matched as a prototype
  t01:('(\\)(\n)'{t01, 1:#[Sâ¯»â”],2:t01nl}   ); #
  t4:('(\\)(\n)'{t4, 1:#[Sâ¯»â”],2:#[SğŸ›‘]}  '(\/)'{#[Z] t4b} );
  t44:('(\\)(\n)'{t44, 1:#[Sâ¯»â”],2:t44nl}  '(?!\/)' );
  # t4:('(\\)(\n)'{t44, 1:#[Sâ¯»â”],2:#[SğŸ›‘]}  câ„âˆ—block );
  t1:(`\`{#[Sâ¯»â”] a1}  câ„âˆ—block* '^(#[Uâ¤S])'{#[SğŸ›‘] n1});
  # a\/**/
  #    â†ğŸ›‘ no empty newline
  t2:(`\`{#[Sâ¯»â”] a2}             '(#[Uâ¤S])'{#[SğŸ›‘] n2} câ„âˆ—block);
  # a\ â†ğŸ›‘ no newline before comments
  # /*
  # */
  t3:(`\`{#[Sâ¯»â”] a3}  câ„âˆ—block   '(#[Uâ¤S])'{#[SğŸ›‘] n3} câ„âˆ—block);
  # a\/**/ â†ğŸ›‘ no newline beween comments
  # /**/
  # 1
  t5:(`\`{#[Sâ¯»â”] a4}  câ„âˆ—block   '(#[Uâ¤S])'{       n4} );
  t6:(`\`{#[Sâ¯»â”] a5}  câ„âˆ—block*  '(#[Uâ¤S])'{       n5} );


el-end{}         	: ('#[Bâ ]' | POP_END); # continue on whitespace or pop if ending mark
node-terminator{}	: TERM_ALONE{1:#[SPTERM]} | CHILD_ABORT{1:#[SPTERM] #[SğŸ›‘]} | CHILD_EXPECT | CHILD_END ;#  câ„line | â¤ | ';' | eof
 TERM_ALONE      	='(;)(?!\{)|(#[Uâ¤S])|(#[EOF])'	# Bâ  not needed as only one match is fine
 CHILD_ABORT     	='(;)(?=\{)'                  	#   while Bâ * produces many as it goes char-by-char
 CHILD_EXPECT    	=   '(?=\{)'                  	#   (?=(#[Bâ ])*\{)
 CHILD_END       	=   '(?=\})'                  	# todo: technically not per spec, clarify whether 'a {b}' is allowed or only 'a {b;}'
 POP_END         	='(?=;|\{|\}|#[Uâ¤S]|#[EOF])'  	# pop before terminator (useful to terminate repeating rules)
# node-terminator{#[SPTERM]}: T1 ;#| TERM_ALONE{a,1:#[SPTERM]} | ABORT_CHILD{ab,1:#[SPTERM] #[SğŸ›‘]} | EXPECT_CHILD{ch};#  câ„line | â¤ | ';' | eof
 # T1 ='(;)|(#[Uâ¤])|(#[EOF])'#

 # câ„line @ prototype  move {#[SPTERM]} to meta scope after bleeding bug is fixed https://github.com/BenjaminSchaaf/sbnf/issues/36
lineâ 	: Uâ¤ | bâ câ„âˆ— | câ„line	;# â‰linespace = newline | ws | single-line-comment

##            	;
uğŸ†”            	: string   | bareğŸ†”         	;# â‰identifier = str | bare-identifier
uğŸ†”-n          	: string-n | bareğŸ†”         	;# make node scope come later
bareğŸ†”         	: keywordÂ¬ | bareğŸ†”âˆ¨keyword 	;# â‰bare-identifier = ((identifier-char - digit - sign) identifier-char* | sign ((identifier-char - digit) identifier-char*)?) - keyword
 bareğŸ†”âˆ¨keyword	:'#[BAREğŸ†”âˆ’Â±]' | '#[BAREğŸ†”Â±]'	;
 BAREğŸ†”        	='#[BAREğŸ†”âˆ’Â±]|#[BAREğŸ†”Â±]'            #
  BAREğŸ†”âˆ’Â±     	=     '(#[CHARğŸ†”âˆ’DIGÂ±])(#[CHARğŸ†”])*'   #
  BAREğŸ†”Â±      	='#[Â±]((#[CHARğŸ†”âˆ’DIG])(#[CHARğŸ†”])*)?'  #
uğŸ†”â„-          	: stringâ„-   | bareğŸ†”â„-      	;#todo temporary disable bool/null
bareğŸ†”â„-       	: keywordÂ¬â„- | bareğŸ†”âˆ¨keyword	;

# uğŸ†”â„-       	: '(#[CHARğŸ†”âˆ’DIGÂ±])(#[CHARğŸ†”])*Ã—?' | '#[Â±]((#[CHARğŸ†”âˆ’DIG])(#[CHARğŸ†”])*)?Ã—?'	;#todo temporary disable bool/null
# uğŸ†”â„-       	: BAREğŸ†”| ('r(#+)?(\")([\s\S]*)?(\")(\1)') ; # adding last element bugs for some reason?
 # Câ„_STR_RAW	= '(r)(#+)?(\")([\s\S]*)?(\")(\2)' #

# UğŸ†”ğŸ›‘       	= '='	#
# uğŸ†”ğŸ›‘{#[SğŸ›‘]}	: UğŸ†”ğŸ›‘	;

## 4 Data           Types                #
 dataâ„-{}	: boolâ„- | nullâ„- | stringâ„- | numberâ„- ;

 BOOL                    	='\b(?:true|false)\b' 	# (?: Non-capturing groups)
 NULL                    	='\b(?:null)\b'       	#
 KEYWORD                 	='(#[BOOL])|(#[NULL])'	# (?>) atomic not supported
 bool{  #[SBOOL]        }	: BOOL                	;#word[BOOL]
 null{  #[SNULL]        }	: NULL                	;#word[NULL]
 boolâ„-{#[SBOOL] #[SCâ„â€”]}	: BOOL                	;#word[BOOL]
 nullâ„-{#[SNULL] #[SCâ„â€”]}	: NULL                	;#word[NULL]

 # todo include S_M_S and common Sâ€œSâ€/SRâ€œSâ€ as left-hand-side meta, but it's bleeding into others, so for now add to each RHS
 # \1 backreferences can't be used in a literal regex, only within the following context that POPs. Older incompatible way is use \k<1>
 # -n elements are "clean" without their content marked to allow meta contents to have a color effect override
 string{    include-prototype:false}	: str-raw   | strâ€œâ€  	;# data type 3/4
 stringâ„-{  include-prototype:false}	: str-rawâ„- | strâ€œâ€â„-	;
 stringâš¿{  include-prototype:false} 	: str-rawâš¿ | strâ€œâ€âš¿  	;
 string-n{  include-prototype:false}	: str-raw-n | strâ€œâ€-n	;
  str-raw{  include-prototype:false}	: STR_RAW{#[S_M_S],1:#[SRR]        ,2:#[Sâ€œ]        ,3:#[Sâ€œ]        ,4:#[SRâ€œSâ€]        ,5:#[Sâ€]        ,6:#[Sâ€]        };
  str-rawâ„-{include-prototype:false}	: STR_RAW{#[S_M_S],1:#[SRR] #[SCâ„â€”],2:#[Sâ€œ] #[SCâ„â€”],3:#[Sâ€œ] #[SCâ„â€”],4:#[SRâ€œSâ€] #[SCâ„â€”],5:#[Sâ€] #[SCâ„â€”],6:#[Sâ€] #[SCâ„â€”]};
  str-raw-n{include-prototype:false}	: STR_RAW{#[S_M_S],1:#[SRR]        ,2:#[Sâ€œ]        ,3:#[Sâ€œ]                           ,5:#[Sâ€]        ,6:#[Sâ€]         };
  str-rawâš¿{include-prototype:false} 	: STR_RAW{#[S_M_S] a,1:#[SRR] #[SCâ„â€”],2:#[Sâ€œ] #[SCâ„â€”],3:#[Sâ€œ] #[SCâ„â€”],4:#[SRâ€œSâ€] #[Sâš¿] #[SCâ„â€”],5:#[Sâ€] #[SCâ„â€”],6:#[Sâ€] #[SCâ„â€”]};
  strâ€œâ€{    include-prototype:false}	:`"`{#[Sâ€œSâ€] #[Sâ€œ]        }  (charsâ€œâ€  )*  `"`{#[Sâ€œSâ€] #[Sâ€]        };
  strâ€œâ€â„-{  include-prototype:false}	:`"`{#[Sâ€œSâ€] #[Sâ€œ] #[SCâ„â€”]}  (charsâ€œâ€â„-)*  `"`{#[Sâ€œSâ€] #[Sâ€] #[SCâ„â€”]};
  strâ€œâ€âš¿{   include-prototype:false}	:`"`{#[Sâ€œSâ€] #[Sâ€œ] #[SCâ„â€”]}  (charsâ€œâ€âš¿ )*  `"`{#[Sâ€œSâ€] #[Sâ€] #[SCâ„â€”]};
  strâ€œâ€-n{  include-prototype:false}	:`"`{#[Sâ€œSâ€] #[Sâ€œ]        }  (charsâ€œâ€-n)*  `"`{#[Sâ€œSâ€] #[Sâ€]        };
  STR_RAWâ€œâ€                         	='(r)#[ESTRâ€œâ€]' # " .* "
 # todo: replace back with charâ€œâ€* when bug is fixed
 strâ€œtest1â€{include-prototype:false}:'(")([^"]*)(")'{#[Sâ€œSâ€], 1:#[Sâ€œ],3:#[Sâ€] };

  STR_RAW	='(r)(?<h>#*)(\")([\s\S]*)(\")(\g<h>)' #todo try to tweak to the new system without \g (separate ending into a popping context to allow \2)
  ESTRâ€œâ€ 	='(")([^"]*)(")' # " .* "
  STR    	='#[STR_RAW]|#[ESTRâ€œâ€]' #  bugs as a rule
  _STR   	='((r)(?<h>#*))?(\")([^"]*)(\")(\g<h>)' #  test, fails since in raw strings ~ in strings [^"]
  -str:STR{#[S_M_S],1:#[SRR],2:#[Sâ€œ],3:#[Sâ€œ],4:#[SRâ€œSâ€],5:#[Sâ€],6:#[Sâ€], 7:#[Sâ€œ],8:#[Sâ€œSâ€],9:#[Sâ€]};
  # splitting also bugs
  r-test  :'(?x)(?<h>[#]+)(?<q> " )'{#[Sâ€œ]} ~ '\g<q>\g<h>'{#[Sâ€]}  ;# # raw-str-hash # | raw-str-quotes

  # combine raw hashed and raw quoted into one â†‘
  sstr-raw{     include-prototype:false} 	: ( sstr-rawï¼ƒ  |   sstr-rawâ€œâ€)  ;#  r raw-str-hash
   sstr-rawï¼ƒ{  include-prototype:false}  	:'(r)(#+)(\")([\s\S]*)(\")(\2)'	{1:#[SRR]       ,2:#[Sâ€œ]        ,3:#[Sâ€œ]        ,4:#[SRâ€œSâ€]       ,5:#[Sâ€]         ,6:#[Sâ€]}	;# # raw-str-hash # | raw-str-quotes
   sstr-rawâ€œâ€{  include-prototype:false} 	:STR_RAWâ€œâ€                     	{1:#[SRR]       ,2:#[Sâ€œ]        ,                3:#[SRâ€œSâ€]       ,4:#[Sâ€]                 };
  # str-rawâ„-{   include-prototype:false}	:(str-rawâ„-ï¼ƒ| str-rawâ„-â€œâ€)  ;
   # str-rawâ„-ï¼ƒ{include-prototype:false} 	:'(r)(#+)(\")([\s\S]*)?(\3)(\2)'    {1:#[SRR] #[SCâ„â€”],2:#[Sâ€œ] #[SCâ„â€”],3:#[Sâ€œ] #[SCâ„â€”],4:#[SRâ€œSâ€] #[SCâ„â€”],5:#[Sâ€] #[SCâ„â€”],6:#[Sâ€] #[SCâ„â€”]}	;# # raw-str-hash # | raw-str-quotes
   # str-rawâ„-â€œâ€{include-prototype:false}	:'(r)(")([^"]*)(")'                  {1:#[SRR] #[SCâ„â€”],2:#[Sâ€œ] #[SCâ„â€”],                3:#[SRâ€œSâ€] #[SCâ„â€”],4:#[Sâ€] #[SCâ„â€”]        };# " .* "

  # risky â†“ due to this bug â†’                        https://github.com/BenjaminSchaaf/sbnf/issues/37
      # S_RAWï¼ƒ                            	='(#+)(\")([\s\S]*)?(\2)(\1)'                                        # # raw-str-hash # | raw-str-quotes
      # str-rawï¼ƒ{include-prototype:false} 	: S_RAWï¼ƒ {1:#[Sâ€œ],2:#[Sâ€œ],3:#[SRâ€œSâ€]        ,4:#[Sâ€],5:#[Sâ€]}	;# # raw-str-hash # | raw-str-quotes
      # S_RAWâ€œâ€                           	='(")([^"]*)(")'                                                      # " .* "
      # str-rawâ€œâ€{include-prototype:false}	: S_RAWâ€œâ€ {1:#[Sâ€œ],        2:#[SRâ€œSâ€]        ,3:#[Sâ€]        };# " .* "
  # â†“ bugged under certain combinations of rules, so stitched all into one regex
   # str-rawï¼ƒ {include-prototype:false}  	:          râ€¹ï¼ƒ                    ~     rï¼ƒâ€º            	;# # raw-str-hash # | raw-str-quotes
   # str-rawï¼ƒ   {include-prototype:false}	:'(?x)(?<h>[#]+)(?<q> " )'{#[Sâ€œ]} ~ '\g<q>\g<h>'{#[Sâ€]}	;# # raw-str-hash # | raw-str-quotes
  # â†“ avoid lookarounds
  # str-rawâ„-{   include-prototype:false}	:câ„-r (str-rawâ„-ï¼ƒ| str-rawâ„-â€œâ€)  ;

 number{}  	: hex   | octal   | binary   | decimal  	;# data type 4/4 (dec last to avoid 0 in 0b parsed by it)
 numberâ„-{}	: hexâ„- | octalâ„- | binaryâ„- | decimalâ„-	;

  ## 4 Number                       Syntaxes
   -boh[b,v]                   	:'([+-])?\b(#[b])(#[v])\b' {1:#[SÂ±]        ,2:#[S_C]base        ,3:#[S_C]value        }	;
   -bohâ„-[b,v]                 	:'([+-])?\b(#[b])(#[v])\b' {1:#[SÂ±] #[SCâ„â€”],2:#[S_C]base #[SCâ„â€”],3:#[S_C]value #[SCâ„â€”]}	;
   binary{   #[SMâ„¤]binary     }	: -boh[  '0b','#[D_BIN]']                                                              	;
   octal{    #[SMâ„¤]octal      }	: -boh[  '0o','#[D_OCT]']                                                              	;
   hex{      #[SMâ„¤]hexadecimal}	: -boh[  '0x','#[D_HEX]']                                                              	;
   binaryâ„-{ #[SMâ„¤]binary     }	: -bohâ„-['0b','#[D_BIN]']                                                              	;
   octalâ„-{  #[SMâ„¤]octal      }	: -bohâ„-['0o','#[D_OCT]']                                                              	;
   hexâ„-{    #[SMâ„¤]hexadecimal}	: -bohâ„-['0x','#[D_HEX]']                                                              	;


   # todo: bug bites again, inline or add '' to the rule, https://github.com/BenjaminSchaaf/sbnf/issues/37
   FLOATâ„¯                	='(#[Â±])?\b#[â„¤ï¼â„¤ï¹–](#[â„¯XP])?\b'	#
   DEC                   	='(#[Â±])?\b#[â„¤ï¼â„¤]\b'          	#
   INTEGER               	='(#[Â±])?\b(#[â„¤])\b'          	#
   decimal{#[S_C]value}  	: #floatâ„¯ | dec | integer     	;# = sign? integer ('.' integer)? exponent?
    (FLOATâ„¯              	{#[SMâ„¯]       ,1:#[SÂ±]        ,2:#[S_Câ„¤] #[S_C]significand        ,4:#[Sâ¯»]decimal
      ,                  	                               5:#[S_Câ„¤] #[S_C]significand
      ,                  	                               6:#[S_Câ„¯]       ,7:#[Sâ¯»â„¯]         ,8:#[SÂ±]        ,9:#[S_Câ„¤]}	# Floating point literal (exponent) 7,8,9 see â„¯XP
    |DEC                 	{#[SMâ„¤]decimal,1:#[SÂ±]        ,2:#[S_Câ„¤]                          ,3:#[Sâ¯»]decimal       ,4:#[S_Câ„¤]}
    |INTEGER             	{#[SMâ„¤]decimal,1:#[SÂ±]        ,2:#[S_Câ„¤]}
    )                    	'';
   decimalâ„-{#[S_C]value}	: #floatâ„¯â„- | decâ„- | integerâ„-	;
    (FLOATâ„¯              	{#[SMâ„¯]       ,1:#[SÂ±] #[SCâ„â€”],2:#[S_Câ„¤] #[S_C]significand #[SCâ„â€”],4:#[Sâ¯»]decimal #[SCâ„â€”]
      ,                  	                               5:#[S_Câ„¤] #[S_C]significand #[SCâ„â€”]
      ,                  	                               6:#[S_Câ„¯] #[SCâ„â€”],7:#[Sâ¯»â„¯] #[SCâ„â€”],8:#[SÂ±] #[SCâ„â€”],9:#[S_Câ„¤] #[SCâ„â€”]}
    |DEC                 	{#[SMâ„¤]decimal,1:#[SÂ±] #[SCâ„â€”],2:#[S_Câ„¤]                   #[SCâ„â€”],3:#[Sâ¯»]decimal #[SCâ„â€”],4:#[S_Câ„¤] #[SCâ„â€”]}
    |INTEGER             	{#[SMâ„¤]decimal,1:#[SÂ±] #[SCâ„â€”],2:#[S_Câ„¤]                   #[SCâ„â€”]}
    )                    	'';

   # todo: â†“ prebugged version, replace back when it's fixed
   -decimal{#[S_C]value}    	: floatâ„¯ | dec | integer      	;# = sign? integer ('.' integer)? exponent?
    integer{#[SMâ„¤]decimal}  	:'(#[Â±])?\b(#[â„¤])\b'          	{1:#[SÂ±]        ,2:#[S_Câ„¤]} ;
    dec    {#[SMâ„¤]decimal}  	:'(#[Â±])?\b#[â„¤ï¼â„¤]\b'          	{1:#[SÂ±]        ,2:#[S_Câ„¤]                          ,3:#[Sâ¯»]decimal       ,4:#[S_Câ„¤]};
    floatâ„¯ {#[SMâ„¯]}         	:'(#[Â±])?\b#[â„¤ï¼â„¤ï¹–](#[â„¯XP])?\b'	{1:#[SÂ±]        ,2:#[S_Câ„¤] #[S_C]significand        ,4:#[Sâ¯»]decimal
      ,                     	                              	                 5:#[S_Câ„¤] #[S_C]significand
      ,                     	                              	 6:#[S_Câ„¯]       ,7:#[Sâ¯»â„¯]        ,8:#[SÂ±]        ,9:#[S_Câ„¤]};# Floating point literal (exponent) 7,8,9 see â„¯XP
   -decimalâ„-{#[S_C]value}  	: floatâ„¯â„- | decâ„- | integerâ„-	;
    integerâ„-{#[SMâ„¤]decimal}	:'(#[Â±])?\b(#[â„¤])\b'          	{1:#[SÂ±] #[SCâ„â€”],2:#[S_Câ„¤]                   #[SCâ„â€”]}                                         	;
    decâ„-    {#[SMâ„¤]decimal}	:'(#[Â±])?\b#[â„¤ï¼â„¤]\b'          	{1:#[SÂ±] #[SCâ„â€”],2:#[S_Câ„¤]                   #[SCâ„â€”],3:#[Sâ¯»]decimal #[SCâ„â€”],4:#[S_Câ„¤] #[SCâ„â€”]}	;
    floatâ„¯â„- {#[SMâ„¯]}       	:'(#[Â±])?\b#[â„¤ï¼â„¤ï¹–](#[â„¯XP])?\b'	{1:#[SÂ±] #[SCâ„â€”],2:#[S_Câ„¤] #[S_C]significand #[SCâ„â€”],4:#[Sâ¯»]decimal #[SCâ„â€”]
      ,                     	                              	                 5:#[S_Câ„¤] #[S_C]significand #[SCâ„â€”]
      ,                     	                              	 6:#[S_Câ„¯] #[SCâ„â€”],7:#[Sâ¯»â„¯] #[SCâ„â€”],8:#[SÂ±] #[SCâ„â€”],9:#[S_Câ„¤] #[SCâ„â€”]};

   # decimalâ„- {#[SMâ„¤]decimal    } :'(#[Â±])?\b#[â„¤](#[ï¼])?(#[â„¤])?(#[â„¯XP])*\b' ''  ;
   #decimal{#[SMâ„¤]decimal}	:'(#[Â±])?#[â„¤]((#[ï¼])(#[â„¤]))?#[â„¯XP]?'	#
   # {#[S_C]value           ,1:#[SÂ±],2:#[S_Câ„¤],4:#[Sâ¯»]decimal,5:#[S_Câ„¤]
   # ,6	:                             #[S_Câ„¯] };

## Helpers                                           #
    keywordÂ¬    	: boolÂ¬  | nullÂ¬    	;
 keywordÂ¬â„-     	: boolâ„-Â¬  | nullâ„-Â¬	;
    keywordâ‚ŒÂ¬   	: boolâ‚ŒÂ¬ | nullâ‚ŒÂ¬   	;
   boolÂ¬{ #[SğŸ›‘]}	: bool       ;# todo: replace with literal if bugs
   nullÂ¬{ #[SğŸ›‘]}	: null	;
 boolâ„-Â¬{ #[SğŸ›‘]}	: boolâ„-       ;
 nullâ„-Â¬{ #[SğŸ›‘]}	: nullâ„-  	;
   boolâ‚ŒÂ¬{#[SğŸ›‘]}	: bool pâ‚ŒğŸ›‘	;
   nullâ‚ŒÂ¬{#[SğŸ›‘]}	: null pâ‚ŒğŸ›‘	;

 POP_S	='(?=\S)'	# return early
 POP  	=''      	# return early

 ### Functions            	                        	#
 word[    pattern]{}      	:'\b(?:#[pattern])\b'   	;# (?: Non-capturing groups)
 wordâ„-[pattern]{#[SCâ„â€”]} 	:'\b(?:#[pattern])\b' ''	;# todo: not sure why bugs in slashdash comments without ''
 wordâš¿[  pattern]{keyword}	: word[pattern]         	;

 ### Identifier	  Parts                              #
  UğŸ”£           	='[\x{0021}-\x{10FFFF}]'            	# invalid: â‰¤0x20 or >0x10FFF)
  CHARğŸ†”Â¬       	=`\/(){}<>;[]=,"`                   	# ! enclose in a [SET] to use
  CHARğŸ†”        	='[#[UğŸ”£]&&[^#[CHARğŸ†”Â¬]]&&[^#[Wâ â¤S]]]'	# â‰  identifier-char = uğŸ”£ - lineâ  - CHARğŸ†”Â¬  since lineâ  has rec comments
  CHARğŸ†”âˆ’DIG    	='[#[CHARğŸ†”]&&[^#[DIGIT]]]'          	#
  CHARğŸ†”âˆ’DIGÂ±   	='[#[CHARğŸ†”âˆ’DIG]&&[^#[Â±]]]'          	#

 #todo: (charâ€œâ€)* bugs, workaround is to use * inside groups or even inside '[^\"]'

 ### String	  Parts	#
  charâ€œâˆâ€{}	:CHARâ€œâˆâ€{#[Sâ€œSâ€],2:#[Sâ‹],4:#[Sâ‹H]};

  charsâ€œâ€{}  	:((`\`{#[Sâ€œSâ€]  #[Sâ‹]        } uâ‹  ) | ('[^\"]*'{#[Sâ€œSâ€]               }))	;
  charsâ€œâ€â„-{}	:((`\`{#[Sâ€œSâ€]  #[Sâ‹] #[SCâ„â€”]} uâ‹â„-) | ('[^\"]*'{#[Sâ€œSâ€]        #[SCâ„â€”]}))	;
  charsâ€œâ€âš¿{} 	:((`\`{#[Sâ€œSâ€]  #[Sâ‹] #[SCâ„â€”]} uâ‹â„-) | ('[^\"]*'{#[Sâ€œSâ€] #[Sâš¿] #[SCâ„â€”]})) 	;
  charsâ€œâ€-n{}	:((`\`{#[S_M_S] #[Sâ‹]        } uâ‹-n) | ('[^\"]*'{#[S_M_S]              }))	;
  charâ€œâ€{}   	:  `\`{#[Sâ€œSâ€]  #[Sâ‹]        } uâ‹    |  '[^\"]'{ #[Sâ€œSâ€]               }  	;
  charâ€œâ€â„-{} 	:  `\`{#[Sâ€œSâ€]  #[Sâ‹] #[SCâ„â€”]} uâ‹â„-  |  '[^\"]'{ #[Sâ€œSâ€]        #[SCâ„â€”]}  	;
  charâ€œâ€-n{} 	:  `\`{#[S_M_S] #[Sâ‹]        } uâ‹-n  |  '[^\"]'{ #[S_M_S]              }  	;
  uâ‹{}       	: charâ‹   | charâ‹u                                                        	;
  uâ‹â„-{}     	: charâ‹â„- | charâ‹uâ„-                                                      	;
  uâ‹-n{}     	: charâ‹-n | charâ‹u-n                                                      	;
   CHARâ€œâˆâ€   	='((\\([#[CHARâ‹]]|(#[CHARâ‹U])))|[^\"])*'
   CHARâ‹     	=`"\/bfnrt`                          	#
   CHARâ‹U    	='u\{#[D1HEX]{1,6}\}'                	#
   charâ‹{}   	:'[#[CHARâ‹]]'{#[Sâ€œSâ€] #[Sâ‹]         }	;
   charâ‹â„-{} 	:'[#[CHARâ‹]]'{#[Sâ€œSâ€] #[Sâ‹]  #[SCâ„â€”]}	;
   charâ‹-n{} 	:'[#[CHARâ‹]]'{#[S_M_S] #[Sâ‹]        }	;
   charâ‹u{}  	:'#[CHARâ‹U]' {#[Sâ€œSâ€] #[Sâ‹H]        }	;
   charâ‹uâ„-{}	:'#[CHARâ‹U]' {#[Sâ€œSâ€] #[Sâ‹H] #[SCâ„â€”]}	;
   charâ‹u-n{}	:'#[CHARâ‹U]' {#[S_M_S] #[Sâ‹H]       }	;

  charsâ€œtstâ€{}	:(('\\'{#[Sâ€œSâ€]  #[Sâ‹]        } ('[#[CHARâ‹]]'{#[Sâ€œSâ€] #[Sâ‹]         }   | '#[CHARâ‹U]' {#[Sâ€œSâ€] #[Sâ‹H]        })  ) | ('[^"]*'{#[Sâ€œSâ€]               }))	;

  r{      include-prototype:false}	: 'r(?=#|")' {#[SRR]}        	;
  râ€¹ï¼ƒ{   include-prototype:false} 	: '(#+)(")'  {#[Sâ€œ]}         	;
  rï¼ƒâ€º{   include-prototype:false} 	:'(")(\1)'  {#[Sâ€]}          	;
  râ„-{  include-prototype:false}  	: 'r(?=#|")' {#[SRR] #[SCâ„â€”]}	;
  râ€¹ï¼ƒâ„-{include-prototype:false}  	: '(#+)(")'  {#[Sâ€œ]  #[SCâ„â€”]}	;
  rï¼ƒâ€ºâ„-{include-prototype:false}  	:'(")(\1)'  {#[Sâ€]  #[SCâ„â€”]} 	;


 ### Number	  Parts                  	#
  Â±        	='[+-]'                  	#
  ï¼        	=`.`                     	#
  â„¯        	='e|E'                   	#
  â„¯XP      	='(#[â„¯])(#[Â±])?(#[â„¤])'   	# â‰ (e|E) sign? integer
  â„¤        	='#[D_DEC]'              	# leading 0s are allowed
  â„¤ï¼â„¤      	='(#[â„¤])(#[ï¼])(#[â„¤])+'   	#
  â„¤ï¼â„¤ï¹–     	='(#[â„¤])((#[ï¼])(#[â„¤])+)?'	#
 ### Number	  Digits                 	#
  DIGIT    	='[0-9]'                 	#
  D_BIN    	='[0-1][0-1_]*'          	#
  D_OCT    	='[0-7][0-7_]*'          	#
  D_DEC    	='[0-9][0-9_]*'          	#
  D1HEX    	='[0-9a-fA-F]'           	#
  D_HEX    	='[#[D1HEX]][#[D1HEX]_]*'	#

# FAIL due to SBNF limits can't use rules in interpolation  #
 ### Number parts                                            #
  #Â±                	:'[+-]'  {#[SÂ±]}       	;
  #base[B]          	:'0#[B]' {#[S_C]base}  	;
  #ddot             	:`.`     {#[Sâ¯»]decimal}	;
  #e                	:'e|E'   {#[Sâ¯»â„¯]}      	;
  #exponent{#[S_Câ„¯]}	: e sign? integer      	;
  #integer{#[S_Câ„¤]} 	: d-dec                	;# leading 0s are allowed


## Comments                                                  #
 câ„-nâ {}               	: câ„-         nâ *                      	;# slash-dash
 câ„line{     #[SCâ„â„] } 	: câ„â„                          ~câ„endâ” 	;# ~lazy match anything up to â¤
 câ„âˆ—block{   #[Sâ„âˆ—Câˆ—â„]}	: câ„âˆ—                           ~câˆ—â„   	; # no ğŸ—˜ version
 câ„âˆ—blockğŸ—˜doc{}        	:     ( câ„âˆ—ï¹—docğŸ—˜ |  câ„âˆ—blockğŸ—˜)         	;# â†’ğŸ—˜ commented_block|doc
  câ„âˆ—blockğŸ—˜{#[Sâ„âˆ—Câˆ—â„]} 	: câ„âˆ— (~câ„âˆ—ï¹—docğŸ—˜ | ~câ„âˆ—blockğŸ—˜)* ~câˆ—â„   	;#  ğŸ—˜ commented_block
  câ„âˆ—ï¹—docğŸ—˜{ #[Sâ„âˆ—ï¹—Câˆ—â„]}	:   câ„âˆ—ï¹— (~câ„âˆ—ï¹—docğŸ—˜ | ~câ„âˆ—blockğŸ—˜)* ~câˆ—â„	;#  ğŸ—˜ commented_block_doc
 #câ„âˆ—block{#[Sâ„âˆ—Câˆ—â„]}  	: (`/*`{#[Sâ„âˆ—]} ~'\*/'{#[Sâˆ—â„]})        	; # backup
 #câ„âˆ—block{ #[Sâ„âˆ—Câˆ—â„]} :'(\/\*)([\s\S]*?)(\*\/)'{1:#[Sâ„âˆ—],3:#[Sâˆ—â„]}; # single-regex FAILs since matches are by line, so blocks can't match newlines inside

 ## Comment atoms                                            #
  Câ„â„âˆ¨â„âˆ—       	='#[Câ„â„]|#[Câ„âˆ—]'	#
  Câ„â„          	=`//`           	#
  Câ„âˆ—          	=`/*`           	#
  Câ„âˆ—ï¹—         	=`/*!`          	#
  Câˆ—â„          	= `*/`          	#
  Câ„â€”          	=`/-`           	#
  Câ„â€”2         	='\/-'          	#
  câ„-{#[SCâ„â€”]} 	:Câ„â€”{ #[Sâ„â€”]}   	;
  câ„-2{#[SCâ„â€”]}	:Câ„â€”2{ #[Sâ„â€”]}  	;# todo: investigate why crashes
  câ„â„          	:Câ„â„{ #[Sâ„â„]}   	;
  câ„endâ”       	: ğŸ”š{#[Sâ„â„Eâ”]}   	;# lookahead needed to pop two contexts
  câ„âˆ—          	: Câ„âˆ—{  #[Sâ„âˆ—]} 	;
  câ„âˆ—ï¹—         	: Câ„âˆ—ï¹—{ #[Sâ„âˆ—ï¹—]}	;
  câˆ—â„          	: Câˆ—â„{ #[Sâˆ—â„]}  	;

# todo: matching spec grammar
nodebâ {}	: (bâ * lâ‹ bâ *) | bâ  bâ *	;#â‰ ws* escline ws* | ws+
nodeâ {} 	: (ws* lâ‹ ws*) | ws ws*	;#â‰ ws* escline ws* | ws+
ws{}    	: bâ câ„âˆ—                	;#â‰ bom | unicode-space | multi-line-comment
lâ‹{}    	: lâ§µ ws* (câ„line | uâ¤) 	;#â‰ \ ws* (single-line-comment | newline)
lâ§µ{}    	:`\`{#[Sâ¯»â”]}           	;
lâ {}    	: uâ¤ | ws | câ„line     	;#â‰ newline | ws | single-line-comment

# todo: comment is not needed as it's part of a prototype? Exclude prototype to highlight illegal lines? (though works fine as is)
Wâ â¤    	='[#[Bâ ]#[Uâ¤]]'      # #no-recur#
Wâ â¤S   	='[#[Bâ ]#[Uâ¤S]]'     # #ss# !!! but doesn't do \r\n as an atom?
bâ câ„âˆ—{}	: bâ  | câ„âˆ—blockğŸ—˜doc	;
EOF    	='$(?!#[Uâ¤S])'       # use #ss#
BOM    	='[\x{FEFF}]'        #
Uâ¤     	='(?>\R)'           # '(?>\r\n?|[\n\x{C}\x{85}\x{2028}\x{2029}])'
Uâ      	='[\x{9}\x{20}\x{A0}\x{1680}\x{2000}\x{2001}\x{2002}\x{2003}\x{2004}\x{2005}\x{2006}\x{2007}\x{2008}\x{2009}\x{200A}\x{202F}\x{205F}\x{3000}]' ## #ss#
Bâ      	='[#[BOM]#[Uâ ]]'                            	# #ss#
Lâ”âˆ…    	='^(#[Bâ ])*#[Uâ¤S]'                          	#     empty line's â¤ (use #ss#)
Lâ”âˆ…â„â„  	='^(#[Bâ ])?(#[Bâ ])*((#[Câ„â„])[\s\S]*)?#[Uâ¤S]'	#     empty line's â¤ with single line comment (use #ss#)
Lâ”âˆ…Â¬   	=   '(?<=.)#[Uâ¤S]'                          	# non empty line's â¤ (use #ss#)
EXPâ¤   	=      '(?=#[Uâ¤S])'                         	# lookahead needed to pop two contexts, todo: fails with (?=(?>\R))
ğŸ”š      	=    '(?=#[Uâ¤S]|#[EOF])'                    	# lookahead needed to pop two contexts, todo: fails with (?=(?>\R))
CHILDÂ¬ 	='(?=\{)'                                   	# the following element is not a {child}
Uâ¤S    	='[\r\n\x{C}\x{85}\x{2028}\x{2029}]'        	# #ss# !!! but doesn't do \r\n as an atom?

#WS   	='(#[Bâ ])|((?>(#[Câ„âˆ—])(.*)(#[Câˆ—â„])))'    # ! fails marking nested blocks, otherwise rule:'#[WS]*'{1:uspb,2:#[Sâ„âˆ—Câˆ—â„],3:#[Sâ„âˆ—],4:inside,5:#[Sâˆ—â„]};
#LINEâ 	='#[Uâ¤]|#[WS]|(?>#[Câ„â„][^#[Uâ¤]]*#[Uâ¤])'  # #no-recur#

# Convert â†‘ to rules â†“ with scope
uâ {}    	:'#[Uâ ]'       	;
bâ {}    	:'#[Bâ ]'       	;
wâ â¤{}   	:'[#[Bâ ]#[Uâ¤]]'	;
uâ¤{}    	:'#[Uâ¤S]'      	;# \R without \v, use #ss#
expâ¤{}  	: '#[EXPâ¤]'    	;
childÂ¬{}	: '#[CHILDÂ¬]'  	;

bâ 2{include-prototype:false}	:'#[Bâ ]'	;

lâ”âˆ…{  include-prototype:false}	:  '#[Lâ”âˆ…]'  {#[SğŸ›‘]}                      	;
lâ”âˆ…â„â„{include-prototype:false}	:  '#[Lâ”âˆ…â„â„]'{1:#[SğŸ›‘], 3:#[SCâ„â„],4:#[Sâ„â„]}	;
lâ”âˆ…Â¬{ include-prototype:false}	:  '#[Lâ”âˆ…Â¬]'{#[SğŸ›‘]}                       	;


## Global Scope vars
SğŸ†”     	='entity.name.'
SğŸ†”ğŸ”–    	='#[SğŸ†”]tag.'
SMAP   	='meta.mapping'
SMâš¿    	='#[SMAP].key meta.property-name'
Sâš¿     	='entity.other.attribute-name'
SMâ‚Œ    	='#[SMAP]'
Sâ‚Œ     	='punctuation.separator.key-value'
SMâ‚ŒV   	='#[SMAP].value meta.property-value'
SM_ARG 	='meta.argument'
SM_PROP	='meta.property'
SP     	='punctuation.definition.'
 SPTERM	='punctuation.terminator.node'
 Sï½›    	='punctuation.section.mapping.begin' #â´âµâ¨â¬ï½›ï½
 Sï½    	='punctuation.section.mapping.end'
SMğŸ”–    	='meta.annotation'
SğŸ›‘     	='invalid.illegal.position' # invalid.illegal.unexpected-text
## Data
SNULL	='constant.language.null'
SBOOL	='constant.language.boolean'
## Number
 SÂ±  	='keyword.operator.arithmetic'
 SMâ„¤ 	='meta.number.integer.'
 SMâ„¯ 	='meta.number.float'
 S_C 	='constant.numeric.'
 S_Câ„¤	='#[S_C]integer'
 S_Câ„¯	='#[S_C]exponent'
 Sâ¯»  	='punctuation.separator.'
  Sâ¯»â„¯	='#[Sâ¯»]exponent'
  Sâ¯»ğŸ”–	='#[Sâ¯»]annotation.'
  Sâ¯»â”	='#[Sâ¯»]continuation.line'
## String
 S_P_STR	='#[SP]string.'
 Sâ€œ     	='#[SP]string.begin'
 Sâ€     	='#[SP]string.end'
 S_M_S  	='meta.string'
 SRR    	='storage.type.string'
 Sâ€œSâ€   	='#[S_M_S] string.quoted.double'
 SRâ€œSâ€  	='#[S_M_S] string.quoted.double.raw'
 Sâ‹     	='constant.character.escape'
 Sâ‹H    	='constant.character.escape.unicode.16-bit-hex'
## Comment
 Sâ„âˆ—Câˆ—â„ 	='comment.block'
 Sâ„âˆ—ï¹—Câˆ—â„	='#[Sâ„âˆ—Câˆ—â„].documentation'
 SCâ„â€”   	='comment.line.slash-dash'
 SCâ„â€”ï½›  	='comment.block.slash-dash'
 SCâ„â„   	='comment.line.double-slash'
 Sâ„     	='#[SP]comment.'
  Sâ„â€”   	='#[Sâ„]begin'
  Sâ„â„   	='#[Sâ„]begin'
  Sâ„âˆ—   	='#[Sâ„]begin'
  Sâ„âˆ—ï¹—  	='#[Sâ„]begin'
  Sâ„â„Eâ” 	='#[Sâ„]end'
  Sâˆ—â„   	='#[Sâ„]end'
  Sâ„â€”ï½  	='#[Sâ„]end'

# todo delete
#CHARğŸ†”REC     	='[#[CHARğŸ†”](?!#[LINEâ ])]'              # recursion: lineâ  â†’ bâ câ„âˆ— â†’ multi_line_comment â†’ commented_blockğŸ—˜
#charğŸ†”rec     	: charğŸ†” (?!lineâ )                    	;# recursion: lineâ  â†’ bâ câ„âˆ— â†’ multi_line_comment â†’ commented_blockğŸ—˜
#bareğŸ†”âˆ¨keyword	: bareğŸ†”-g-pre | '#[Â±]' (bareğŸ†”-g-pos)?	;
#bareğŸ†”-g-pre  	: charğŸ†”âˆ’digÂ± charğŸ†”rec*               	;# pre-sign: exclude digit/sign to avoid clashes
#bareğŸ†”-g-pos  	: charğŸ†”âˆ’dig  charğŸ†”rec*               	;# pos-sign: exclude digit only
#charğŸ†”âˆ’dig    	:'[[#[CHARğŸ†”]]&&[^#[DIGIT]]]'         	;
#charğŸ†”âˆ’digÂ±   	:'[[#[CHARğŸ†”âˆ’DIG]]&&[^#[Â±]]]'         	;
#charğŸ†”rec     	:'#[CHARğŸ†”]'                          	;# recursion: lineâ  â†’ bâ câ„âˆ— â†’ multi_line_comment â†’ commented_blockğŸ—˜
# comments
 ## todo?	del?               	#
  #Câ„â„   	=`//`              	#
  #Câ„âˆ—   	=`/*`              	#
  #Câˆ—â„   	= `*/`             	#
#eof     	: '#[EOF]'         	;
#uâ       	:'#[Uâ ]'           	;
#bâ       	:'#[Bâ ]'           	;
#bom     	:'#[BOM]'          	;
NEXTâ€œ    	='(?=r\"|r#*\"|\")'	# not sure why needed as a workaround
nextâ€œ    	: NEXTâ€œ            	; #r###"


Z 	='#[SP]string.DEBUG'  #
ZR	='#[SğŸ›‘].DBG'
ZB	='#[SğŸ†”ğŸ”–]DBG'
ZG	='#[Sâ€œSâ€]DBG'
ZN	='#[S_C]DBG'
ZO	='#[Sâš¿].DBG'



_S_S='Stringify everything'
# but for stringify I'd need capturing groups
_1 = '()'
_2 = '()()'
_3 = '()()()'
_4 = '()()()()'
_5 = '()()()()()'
_6 = '()()()()()()'
_7 = '()()()()()()()'
_8 = '()()()()()()()()'
_9 = '()()()()()()()()()'
NNM='("?[a-z]"?)+' #NNM='(#[BAREğŸ†”])+'
TTYP='\(r?"?[a-zA-Z\d]+"?\)' TVAL='"?[a-zA-Z\d]+"?'
TBOOL      	='()(?<t>true)|false|null'
Câ„â€“TBOOL   	='\/-\ *(#[TBOOL])'
Câ„â€“T_BOOL  	='\/-\ *((#[TTYP])(#[TBOOL]))'
T_BOOL     	=    '(#[TTYP])(#[TBOOL])'
TDIG       	='[e_\d\+\-\.]+'
Câ„â€“TDIG    	='\/-\ *(#[TDIG])'
Câ„â€“T_DIG   	='\/-\ *((#[TTYP])(#[TDIG]))'
T_DIG      	=    '(#[TTYP])(#[TDIG])'
P_STRâ‚ŒV    	=           '#[STR]#[Pâ‚Œ]#[TVAL]'
Câ„â€”P_STRâ‚ŒV 	='\/-\ *(#[P_STRâ‚ŒV])'
STRâ‚ŒTYPV   	=           '#[STR]#[Pâ‚Œ]#[TTYP]#[TVAL]'
Câ„â€”STRâ‚ŒTYPV	='\/-\ *(#[STRâ‚ŒTYPV])'
T_STR      	=    '#[TTYP]#[STR]'
Câ„â€“T_STR   	='\/-\ *#[T_STR]'
Câ„â€”STR     	='\/-\ *(#[STR_E])'

Pâš¿â‚ŒV     	=    '#[Pâš¿]#[Pâ‚Œ]#[TVAL]'
Câ„â€”Pâš¿â‚ŒV  	= '\/-#[Pâš¿]#[Pâ‚Œ]#[TVAL]'
Pâš¿â‚ŒT_V   	=    '#[Pâš¿]#[Pâ‚Œ]#[TTYP]#[TVAL]'
Câ„â€”Pâš¿â‚ŒT_V	= '\/-#[Pâš¿]#[Pâ‚Œ]#[TTYP]#[TVAL]'

Pâš¿='#[NNM]'
# STR_RAW uses named groups not to depend on relative position
STR_E	='#[STR_RAW]|#[ESTRâ€œâ€]' #  bugs as a rule

T_END=';|\n' TPOP_END='(?=#[T_END])'
# NOTYP='(?!\()' # not needed since values are forbidden to start with (
el-stringify{}: nâ 
  |(Câ„â€“T_STR{ â„â€“()â€œargâ€                   })
  |(Câ„â€“T_BOOL{a()kw #[SBOOL]              })
  |(Câ„â€“T_DIG{ a()ğŸ”¢ #[S_C]value            })
  |(Câ„â€”STRâ‚ŒTYPV{â„â€“()â€œâš¿â€                   })
  |(Câ„â€”P_STRâ‚ŒV{ â„â€“â€œâš¿â€                     })
  |(Câ„â€”Pâš¿â‚ŒV{   Câ„â€”âš¿                       })
  |(Câ„â€”Pâš¿â‚ŒT_V{ Câ„â€”âš¿()                     })
  |(Câ„â€”STR{     â„â€“â€œargâ€                   })
  |(Câ„â€“TBOOL{   a-kw #[SBOOL]             })
  |(Câ„â€“TDIG{    ağŸ”¢ #[S_C]value            })
  |(   T_STR{ ()â€œargâ€                     })
  |(   T_BOOL{a-kw #[SBOOL]               })
  |(   T_DIG{ atğŸ”¢ #[S_C]value             })
  |(   STRâ‚ŒTYPV{ â€œâš¿â€()                    })
  |(   P_STRâ‚ŒV{  â€œâš¿â€                      })
  |(   Pâš¿â‚ŒV{    âš¿                         })
  |(   Pâš¿â‚ŒT_V{  âš¿()                       })
  |(   STR{     â€œargâ€                     })
  |(   TBOOL{   #[SBOOL],1:b,2:b2 })
  |(   TDIG{    ağŸ”¢ #[S_C]value })
  ;
