%YAML 1.2
---
name             : KDL2
file_extensions  : [kdl,kdl2]
scope            : text.kdl2
first_line_match : '/-[[:blank:]]*kdl-version[[:blank:]]+2[[:blank:]]*$'
version          : 2
extends          : Packages/KDL/KDL2â„-.sublime-syntax
# BOM \x{FEFF}? doesnt' seem to be part of a line for re matching, so not added though it's part of the spec
# See Whitespace (Line breaking and non-Newline) in a separate re_st_engine.sublime-syntax

# !sets don't allow whitespace even with (?x:), so watch out for [{{var}}] where var='(?x: abc)', 'x' will also be included
  # _digit _char = set-safe [{{var_s}}], i.e. contains only characters, no conditional matching groups
  # use syntax rules instead of variables that can't be recursive
  # lookaheads skip meta scopes, so might need to repeat them
# quote regexes with # : - { [ >
# Oniguruma regex engine features
  # rbuckton.github.io/regexp-features/engines/oniguruma.html
  # raw.githubusercontent.com/kkos/oniguruma/v6.9.1/doc/RE  6.8.0 2018/07/26 (not sure which version ST uses)
    # github.com/kkos/oniguruma/blob/master/doc/RE (latest)
# \k<> named group, while \g<> is recursion!
# include ignores meta patterns in the included contexts

# not all variables have been updated to match v2
# ident = identifier #âŠ=set safe #âˆª set safe with exception
# _var = var rules can't be expressed within literal regexes, e.g., excluding keywords
variables:
  # nodes:                	'(?x: {{linesp_re}}*                                     	#
  #   (?##)               	   ({{node}} {{nodes}}?)?                                	#
  #   (?##)               	      {{linesp_re}}*                                     	)' #
  # node:                 	'(?x:                                                    	#
  #   (?##)               	 (/\- {{n_sp}}*)?                                        	# Slashdash comment
  #   (?##)               	                       {{type}} ? {{ID}}                 	#
  #   (?##)               	      ({{n_sp}}+ {{node_prop_or_arg}} )*                 	#
  #   (?##)               	      ({{n_sp}}* {{node_children}} {{ws}}*)?             	#
  #   (?##)               	       {{n_sp}}* {{node_terminator}}                     	)' #
  # node_prop_or_arg:     	'(/\-{{n_sp}}*)?({{prop}}|{{value}})'                    	#
  # node_children:        	'(/\-{{n_sp}}*)?{{{nodes}}}'                             	#
  # n_sp:                 	'{{ws}}*{{escline}}{{ws}}*|{{ws}}+'                      	#
  # node_sp_beg:          	'{{ws_beg}}|{{escline_beg}}'                             	#
  # line_sp_beg:          	'{{ws_beg}}|{{c_line_beg}}|{{nl_s}}'                     	#
  # any_sp_t_beg:         	'{{node_sp_beg}}|{{node_term_beg}}'                      	#
  # node_sp_end:          	'{{ws_end}}' #|{{escline_end}} âœ— needs previous line     	#
  # pre_val:              	'^|\=|\)|{{node_sp_end}}'                                	# line begin^ as line-cont surrogate
  # ws_beg:               	'{{u_sp}}|{{comment_block_beg}}'                         	#
  # ws_end:               	'{{u_sp}}|{{comment_block_end}}'                         	#
  # node_terminator:      	'{{comment_line}}|{{newline}}|;|{{eof}}'                 	#
  # node_term_beg:        	'{{c_line_beg}}|;|{{eof}}|{{nl_s}}'                      	#
  # node_term_beg_no_nl:  	'{{c_line_beg}}|;|{{eof}}'                               	#
  #                       	                                                         	#
  # # bareID:             	'(?!{{keyword}}[^{{charID}}]){{bareID_or_KW}}'           	#
  bareID_or_KW:           	'{{bareID_ex09dsign}}|{{bareID_ex09}}'                   	#
  bareID_ex09dsign:       	'{{charID_ex09dsign}}{{charID}}*'                        	# pre-sign: exclude digit/dot/sign to avoid clashes
  bareID_ex09d:           	'[+-](?:{{charID_ex09d}}{{charID}}*)?'                   	# pre-sign: exclude digit/dot
  bareID_ex09:            	'[+-]?\.(?:{{charID_ex09}}{{charID}}*)?'                 	# pos-sign: exclude digit only
  charID:                 	'[[{{uchar}}]&&[^{{charWS}}]&&[^{{charID_not}}]]'        	# charğŸ†” â‰ uchar âˆ’ uâ  âˆ’ â¤ âˆ’c harğŸ†”Â¬ âˆ’ charğŸ›‘
  charID_or_KW:           	'[{{charID}}\#]'                                    #âŠ   	#
  charID_not:             	'[\/\\(){};\[\]=#"]'                                #âŠ   	# charğŸ†”Â¬ â‰ #"(;){"}[#]/=\"#
  charID_not1st:          	'([0-9])|([+-]|[+-]?\.)([0-9])'                 #.       	#
  kw1_not:                	'(true|false|null|inf|-inf|nan)'         #.              	# keywordğŸ†”ğŸ›‘ â‰ true | false | null | inf | -inf | nan
  # kw1_not_glast5:         	'(tru(e)|fals(e)|nul(l)|-?in(f)|na(n))'     #.           	#
  # charWS:               	'[{{nl_s}}{{u_sp}}]'                                #âˆª   	#\r\n sequence not accounted for
  # charID_rec:           	'{{charID}}(?!{{linesp_re}})'                            	# set-unsafe; includes recursion: linespace â†’ ws â†’ comment_block â†’ commented_blockğŸ—˜
  # charID_ex09:          	'[[{{charID}}]&&[^0-9]]'                                 	#charğŸ†” âˆ’ ã€”0â€“9ã€•
  charID_ex09d:           	'[[{{charID_ex09}}]&&[^\.]]'                             	#charğŸ†” âˆ’ ã€”0â€“9ã€•     âˆ’ .
  charID_ex09dsign:       	'[[{{charID_ex09}}]&&[^\.]&&[^+-]]'                      	#charğŸ†” âˆ’ ã€”0â€“9ã€• âˆ’ Â± âˆ’ .
  # unicode_char:         	'[\x{0021}-\x{10FFFF}]'                             #âŠ   	# invalid: â‰¤0x20 or >0x10FFF)
  uchar:                  	'[\x{0000}-\x{D7FF}\x{E000}-\x{10FFFF}]' #âŠ              	#
  # keyword:              	'{{boolean}}|{{nil}}'                                    	#
  # prop:                 	'{{ID}}={{value}}'                                       	#
  # prop_eq:              	'({{u_sp}}?)({{u_sp}}*)(=)({{u_sp}}?)({{u_sp}}*)'        	#
  # value:                	'{{type}}?({{string}}|{{number}}|{{keyword}})'           	#
  type:                   	'\({{n_sp}}*{{ID}}{{n_sp}}*\)'                           	#type â‰ "(" nâ * string nâ * ")"
  #                       	                                                         	#
  char_illegal:           	'[{{bom}}{{c0a}}{{c0b}}{{cdel}}{{usv_not}}{{cdir}}]' #âŠ  	# ST doesn't allow tracking BOM@file begin, so no need to add a BOF condition
  c0a:                    	  '[\x{0000}-\x{0008}]'                            #âŠ    	#
  # c0valid:              	  '[\x{0009}-\x{000D}]'                            #âŠ    	#9â‰\t AâŠ\n Bâ‹\v CâŒ\f Dâ\r
  c0b:                    	  '[\x{000E}-\x{001F}]'                            #âŠ    	#
  cdel:                   	  '[\x{007F}]'                                     #âŠ    	#
  usv_not:                	  '[{{surrog_high}}{{surrog_low}}]'                #âŠ    	# not Unicode scalar value
  usv_not_hex:            	  '0?0?[dD][8-9a-fA-F]{{d_hex}}{2}'                #.    	#
  surrog_high:            	    '[\x{D800}-\x{DBFF}]'                          #âŠ    	#
  surrog_low:             	    '[\x{DC00}-\x{DFFF}]'                          #âŠ    	#
  cdir:                   	  '[\x{200E}-\x{200F}\x{202A}-\x{202E}\x{2066}-\x{2069}]'	#âŠ
  # usv_fmt_not_hex:      	  '0{1,5}{{d_hex}}{1,5}'                           #âŠ    	# can be > max, so put lower in priority vs codepoint_not_hex
  codepoint_not_hex:      	  '{{d_hex}}{7,}|{{cp_max1_hex}}|{{cp_max2_hex}}'        	#1234567>10FFFF
  cp_max1_hex:            	    '[2-9a-fA-F]{{d_hex}}{5}'                      #âŠ    	#20FFFF>10FFFF
  cp_max2_hex:            	    '1[1-9a-fA-F]{{d_hex}}{4}'                     #âŠ    	#11FFFF>10FFFF
  escaped_string:         	'"{{str_body_line}}"|"""{{str_mline}}"""'                	#
  str_body_line:          	'{{char_str1}}*'                                         	#string_body_line â‰ â¦…char_str - â¤â¦†*
  str_mline:              	'{{newline}}{{str_bodymline}}{{newline}}({{esc_uws}})*'  	#
  str_bodymline:          	'"?"?{{char_str}}*'                                      	#
  char_str:               	'{{escaped}}|[^"]'                                       	#char_str â‰ charâ‹ | uniâ‹ | wâ â‹ | ã€”Â¬â§µâ€œã€• - charğŸ›‘
  char_str1:              	'{{escaped}}|[^"\n]'                                     	#char_str - â¤
  escaped:                	'{{esc_char}}|{{esc_uni}}|{{esc_ws}}'                    	#
  esc_char_s:             	'["\\bfnrts]'                                     #âŠ     	#v2: +s âˆ’/
  esc_char:               	'\\{{esc_char_s}}'                                       	#charâ‹ â‰ â§µ ã€”â€œâ§µbfnrtsã€•
  esc_uni:                	'\\u{{{d_hex}}{1,6}}'                                    	# uniâ‹ â‰ â§µ "u{"; ucharâ‚â‚† "}"
  esc_ws:                 	'\\({{u_sp}}|{{newline}})+'                              	# wâ â‹ â‰ â§µ â¦…uâ |â¤â¦†+
  esc_uws:                	'{{u_sp}}|{{esc_ws}}'                                    	#
  esc_usv_not:            	'u{{{usv_not_hex}}}'                                     	#
  # d_hex:                	'[0-9a-fA-F]'                                            	#
  # d_hex_:               	'[0-9a-fA-F_]'                                           	#
  #                       	                                                         	#
  boolean:                	'(?:\#true|\#false)'                                     	# data type 1/4
  nil:                    	'(?:\#null)'                                             	# data type 2/4
  # string:               	'{{raw_string}}|{{escaped_string}}'                      	# data type 3/4
  number:                 	'{{floatkw}}{{decimal}}|{{hex}}|{{octal}}|{{binary}}' #. 	# data type 4/4
  #    â†“string            	                                                         	#
  raw_string:             	 '(#+)?(\")([\S\s]*?)(\")(\2)'                           	#
  raw_string_re:          	 '{{raw_string_hash_re}}'                                	#ğŸ—˜
  # raw_string_hash_re:   	'#{{raw_string_hash_re}}#|{{raw_string_quotes}}'         	#ğŸ—˜
  # raw_string_quotes:    	'".*"'                                                   	#
  string_beg:             	'"|#*"'                                                  	# or (?!r)"|#*"
  # string_end:           	'"#*'                                                    	# or (?!r)"|#*"
  #    â†“number            	                                                         	#
  floatkw:                	'(\#inf|\#-inf|\#nan)'                     #.            	# ? not uncapturing like nil?
  # decimal:              	      '([+-])?({{integer}})(\.{{integer}})?{{exponent}}?'	#
  # exponent:             	'([eE])([+-])?({{integer}})'                             	#
  # integer:              	'[0-9][0-9_]*'                                           	# leading 0s are allowed
  # #sign:                	'[+-]'                                               #âŠ  	# using [+-] is cleaner than {{sign}}
  #                       	                                                         	#
  # hex:                  	'([+-])?(0x)({{d_hex}}{{d_hex_}}*)'                      	#
  # octal:                	'([+-])?(0o)([0-7][0-7_]*)'                              	#
  # binary:               	'([+-])?(0b)([0-1][0-7_]*)'                              	#
  #                       	                                                         	#
  # escline:              	'\\{{ws}}*({{comment_line}}|{{nl_s}})'                   	#
  # escline_beg:          	'\\'                                                     	#
  # linesp_re:            	'{{nl_s}}|{{ws}}|{{comment_line}}'                       	# set-unsafe; includes recursion: ws â†’ comment_block â†’ commented_blockğŸ—˜
  # char_linesp:          	'[{{nl_s}}{{u_sp}}{{c_beg}}]'                       #âˆª   	# ex / but not precisely //
  # newline:              	'(?>\r\n?|[\x{A}\x{B}\x{C}\x{85}\x{2028}\x{2029}])' #.   	# \R
  # nl_s:                 	'[\r\n\x{B}\x{C}\x{85}\x{2028}\x{2029}]'            #âˆª   	# not precisely â¤âŠ
  nl_not_s:               	'[^{{nl_s}}]'                                      #âŠ    	#
  ws:                     	 '{{u_sp}}|{{comment_block}}'                            	#
  b_sp:                   	'{{u_sp}}'                                          #âŠ   	#left to override v1 syntax
  uspnl:                  	'{{u_sp}}|{{newline}}'                              #.   	#
  # uspnl_s:              	'[{{u_sp}}{{nl_s}}]'                               #âˆª    	#
  # bom:                  	'[\x{FEFF}]'                                             	#
  # unicode_space:        	'[[:blank:]]'                                       #âŠ   	#
  # comment_line:         	'({{c_line_beg}})([^{{nl_s}}]*)({{c_line_end}})'         	#
  # comment_line_no_nl:   	'({{c_line_beg}})([^{{nl_s}}]*)'                         	#
  # comment_block:        	'{{comment_block_beg}}{{commented_block}}'               	# set-unsafe; recursion: commented_blockğŸ—˜
  # c_beg:                	'/'                                                      	#
  # c_slashdash:          	'/-'                                                     	#
  # c_line_beg:           	'//'                                                     	#
  # c_line_end:           	'{{nl_s}}|{{eof}}'                                       	#
  # eof:                  	'$(?!{{nl_s}})'                                          	#
  # eof_x:                	'(?=[\S\s]{{eof}})' # when â†‘ bugs                        	#
  # comment_block_beg:    	'/\*'                                                    	#
  # comment_block_doc_beg:	'{{comment_block_beg}}(!|\*(?!/))'                       	#
  # commented_block:      	'\*/|({{comment_block}}|\*|/|[^*/]+){{commented_block}}' # !!! cant recurse vars, do via syntax
  # comment_block_end:    	'\*/'                   	#
  # comment_block_doc_end:	'{{comment_block_end}}' 	#
  u_sp_not:               	'[^{{u_sp}}]'         #âŠ	#
  # u_sp: '[\x{9}\x{20}\x{A0}\x{1680}\x{2000}\x{2001}\x{2002}\x{2003}\x{2004}\x{2005}\x{2006}\x{2007}\x{2008}\x{2009}\x{200A}\x{202F}\x{205F}\x{3000}]' #âŠ #
  ID: '{{string}}|((?!({{keyword}})[^{{charID}}])({{bareID_ex09dsign}}|{{bareID_ex09d}}|{{bareID_ex09}}))' # bugs as 'recursive' if replace inlined vars with the same combo var
  bareID:        '((?!({{keyword}})[^{{charID}}])({{bareID_ex09dsign}}|{{bareID_ex09d}}|{{bareID_ex09}}))' # bugs as 'recursive' if replace inlined vars with the same combo var
  # â†‘ excludes keywords, but string would be a pain to style

contexts:
  prototype:
    - include: chğŸ›‘s
  #   # - include: wss
  #   # - include: comment_blockâˆ¨doc
  #   # - meta_include_prototype: false
  #   # todo: bugs e.g. (a)/**/1 is a comment even if you exclude everywhere

  main:
    - meta_include_prototype: false
    - match : ''
      push  : #âœ—â°
      #- meta_scope        : dbgâœ—Â¹
      - include: nodes

  # nodes: #âœ—â° â‰ â¦…l_â *â €nodeâ¦†* l_â *
  #   - include: linesp
  #   - include: node
  #   - include: anyğŸ›‘ # todo disable? strict mode
  #   # - include: any-pop

#â€”â€”â€” 0 Groups
  node-elements:          #âœ—Â²
    - match               : (?={{node_sp_beg}}) # mandatory whitespace
      push                : #âœ—Â³ push to require ws before each element
      #- meta_scope        : dbgâœ—Â³nodeâ argâˆ¨propâˆ¨child
      - include           : nodeâ s
      - include           : node_châˆ¨argpropâ„-
      - match             : '({{c_slashdash}})'
        scope             : comment.line.slash-dash.kdl punctuation.definition.comment.begin.kdl
        pop               : 1
        set               :
        #- meta_scope      : dbgâœ—Â³nodeâ â„âˆ’argâˆ¨propâˆ¨child
        - include         : linesp
        - include         : node_terminatorğŸ›‘3
        - include         : argâˆ¨propâ„-
        # - include         : child_blockâ„-
        - include         : pop # todo not style /- empty via branches above â†‘
        # - include         : SğŸ›‘Â¹pre_sâˆ¨câˆ¨t
      - include           : argâˆ¨prop
      - include           : child_block
      - include           : ï½
      - include           : node_terminator4  # ... but then an extra pop is needed
    - include             : child_block3
    - include             : nodech_terminator3â¸®
    - include             : SğŸ›‘Â¹pre_sâˆ¨câˆ¨t
    # - include: comments
    # - include: charğŸ†”Â¬

  str_id: # strğŸ†” â‰ cleanğŸ†” | signedğŸ†” | dottedğŸ†”
    - include             : keyword1strğŸ›‘preâ â¤
    - match               : '([+-]|[+-]?\.)([0-9])'
      captures            :
        1:                  invalid.illegal.position.kdl
        2:                  invalid.illegal.muted.position.kdl
    - match               : '{{bareID}}'
      push                :
      - meta_scope        : meta.string.kdl string.unquoted.kdl
      - match             : '{{charID}}'
        scope             : string.unquoted.kdl
      - include           : charğŸ†”Â¬
      - include           : pop

  string:
    - include: string-quoted-double3
    - include: string-quoted-double
    - include: string-quoted-double3-raw
    - include: string-quoted-double-raw
  strings:
    - include: strings-quoted-double3
    - include: strings-quoted-double
    - include: strings-quoted-double3-raw
    - include: strings-quoted-double-raw
  strings_node-id:
    - include: strings-quoted-double3_node-id
    - include: strings-quoted-double_node-id
    - include: strings-quoted-double3-raw_node-id
    - include: strings-quoted-double-raw_node-id
  # number:
  #   - include: binÂ¦octÂ¦hex-partial
  #   - include: hexadecimal
  #   - include: octal
  #   - include: binary
  #   - include: intâˆ¨decâˆ¨float
  # comments:
  #   - include: comment_blockâˆ¨doc
  #   # - include: comment_slashdash
  #   - include: comment_line
  # comment_blockâˆ¨doc:
  #   - include: comment_block_doc
  #   - include: comment_block
  keyword:
    - include: keyword-partial
    - include: boolean
    - include: nil
    - include: floatkw
  keywordğŸ›‘:
    - include: booleanğŸ›‘
    - include: nullğŸ›‘
    - include: floatkwğŸ›‘
  keyword-partial: # avoid red flashes with unfinished typing
    - include: bool-partial
    - include: null-partial
    - include: floatkw-partial
  keyword-partial-extğŸ›‘: # avoid red flashes with extra #keyword_typing
    - include: bool-partial-extğŸ›‘
    - include: null-partial-extğŸ›‘
    - include: floatkw-partial-extğŸ›‘
  keyword1strğŸ›‘preâ â¤:
    - include             : keyword1strğŸ›‘preâ ï¼›
    - include             : keyword1strğŸ›‘preâ¤
  keyword1nodeğŸ›‘preâ â¤:
    - include             : keyword1nodeğŸ›‘preâ ï¼›
    - include             : keyword1nodeğŸ›‘preâ¤


#â€”â€”â€” 1 Node: \- type
  node:                   #âœ—â° â‰ node_base node_end
    - include             : node_base
    - include             : node_terminator
  node_base:              #âœ—â°
    - include             : â„-node
    - include             : nodetID
  nodetID:                #âœ—â°
    - match               : '(?=\()'
      push                :
      - meta_scope        : meta.node.kdl #âœ—Â¹node_base_t
      - include           : type-node
    - match               : '(?={{string_beg}}|{{bareID}})'
      push                :
      - meta_scope        : meta.node.kdl #âœ—Â¹node_base_s_b
      - include           : nodeID

  type-node:              #âœ—Â¹
    - match               : \(
      scope               : punctuation.separator.annotation.begin.kdl
      push                : #âœ—Â²
      - meta_scope        : meta.annotation.kdl #âœ—Â²m
      - meta_content_scope: entity.name.type.kdl #âœ—Â²c
      - match             : '(?<=\()(\))|(\))'
        captures          :
          1:                invalid.illegal.muted.kdl #punctuation.separator.annotation.end.kdl invalid.illegal.position.kdl
          2:                punctuation.separator.annotation.end.kdl #âœ—typenode_close
        pop               : 2 # remove 1st annotation, 2 fixes a bug?
        set               : #âœ—Â¹ # push bugs even with pop, still get meta_content
        - include         : nodeâ 
        - include         : nodeID
        - include         : charğŸ†”Â¬
        - include         : anyğŸ›‘s
      - include           : nodeâ 
      - include           : type-content-node
      - include           : typeğŸ›‘

  type-content-node:      #âœ—Â²
    - include             : keywordğŸ›‘
    - match               : '(?={{string_beg}})' # string can't just use to ban "a""b"
      push                : #âœ—Â³
      # - meta_scope        : dbgtype-content-nodeâœ—Â³
      - include           : strings-quoted-double-raw-consecutiveğŸ›‘ # ..gs allows popping later on )
      - include           : strings-quoted-double-consecutiveğŸ›‘
      - include           : strings
      - include           : pop_preï¼‰ # remove â†‘
      - include           : anyğŸ›‘s
    - include             : ID_bare_sğŸ›‘



#â€”â€”â€” 2 Node Element: 1 Name
  nodeID:                 #âœ—Â¹
    # - include             : keywordsğŸ›‘
    - include             : keyword1nodeğŸ›‘preâ â¤
    - match               : '(?={{string_beg}})'
      push                : #âœ—Â²
      # - meta_scope        : entity.name.tag.node.kdl #âœ—Â²
      - include           : string-quoted-double-raw-consecutiveğŸ›‘3
      - include           : string-quoted-double-consecutiveğŸ›‘3
      - include           : strings_node-id # use custom strings scopes or meta_scope gets applied to "args"
      - include           : node-elements
      # - include           : node_terminator3
    - include             : bare-after-stringğŸ›‘
    - match               : '([+-]|[+-]?\.)([0-9])'
      scope               : entity.name.tag.node.kdl
      captures            :
        1:                  invalid.illegal.position.kdl
        2:                  invalid.illegal.muted.position.kdl
    - match               : '{{bareID}}'
      scope               : entity.name.tag.node.kdl
      push                : #âœ—Â²
      #- meta_scope        : dbgâœ—Â²_nodeIDâ†’node_elements
      - include           : node-elements
      # - include           : node_terminator3
      - include           : SğŸ›‘s

#â€”â€”â€” 2 Node Element: 2 Argument or 3 Property
  # argâˆ¨prop:               #âœ—Â³
  #   # - include           : nodeâ 
  #   - include             : arg_typed
  #   - include             : arg_untypedâˆ¨prop

  arg_untypedâˆ¨prop:       #âœ—Â³
    - match               : '(?={{string_beg}})'
      branch_point        : â¸™1â€œargâˆ¨propâ€
      branch              : #âœ—â´â¸™
        - â€œargâ€-â¸™1
        - â€œâš¿â€â‚Œv-â¸™1
    - match               : '(?={{charID_or_KW}})'
      branch_point        : â¸™2argâˆ¨prop
      branch              : #âœ—â´â¸™
        - arg-â¸™2
        - âš¿â‚Œv-â¸™2

#â€”â€”â€” 2 Node Element: 2 Argument
  â€œargâ€-â¸™1:               #âœ—â´
    - meta_scope          : meta.argument.value.kdl meta.mapping.value.kdl #âœ—â´â€œargâ€â¸™1
    - include             : â€œargâ€
    - include             : â€œargâ€ğŸ›‘
    - include             : popâ¸™
  arg-â¸™2:                 #âœ—â´
    - meta_scope          : meta.argument.value.kdl meta.mapping.value.kdl #âœ—â´argâ¸™2
    - include             : nodeâ 
    - match               : '{{prop_eq}}'
      fail                : â¸™2argâˆ¨prop
    - match               : '(\S*)(?==)'
      fail                : â¸™2argâˆ¨prop
    - include             : value
    - include             : str_id
    - include             : valueğŸ›‘
    - include             : pop_preâ¤
    - include             : popâ¸™

  # arg_typed:              #âœ—Â³
  #   - match               : (?=\()
  #     set                 :
  #     - meta_scope        : meta.argument.value.kdl meta.mapping.value.kdl #âœ—Â³typed
  #     - include           : type-value
  # â€œargâ€:                  #âœ—â´
  #   # - include             : string  # can't use as is since branch check comes after we're inside a string!
  #   - match               : '(?={{string_beg}})'
  #     push                : #âœ—âµ
  #     # - meta_scope        : dbgâ€œargâ€âœ—âµ
  #     - include           : string-quoted-double-raw-consecutiveğŸ›‘3
  #     - include           : string-quoted-double-consecutiveğŸ›‘3
  #     - include           : strings
  #     - match             : '{{prop_eq}}'
  #       fail              : â¸™1â€œargâˆ¨propâ€
  #     - include           : pop3  # Â¹arg_untypedâˆ¨prop branch Â²â†‘ 3 exit

  ## arg:                    #âœ—â´
  ##   - include             : type-value
  ##   - include             : value
  ##   - include             : valueğŸ›‘

  # value:                  #âœ—â´
  #   - include             : keyword
  #   - include             : string
  #   - include             : number
  # valğŸ›‘: # todo: combine?
  #   - include             : pop2_preâ 
  #   - include             : pop2_preâ¤
  #   - include             : pop2_pre-term
  #   # - include             : pop2_pre-str
  #   # - include             : charğŸ†”Â¬
  #   # - include             : pop_preğŸ†”Â¬  # let previous layers deal with invalid chars
  #   - include             : chğŸ›‘preâ    # todo: or just scrap illegals? let unstyled content be the indicator
  valueğŸ›‘:
    - include             : ï¼ƒmaybe-keywordğŸ›‘
    - include             : valğŸ›‘
    - include             : chğŸ›‘pre_term
    - include             : chğŸ›‘pre-str
  # â€œargâ€ğŸ›‘:
  #   - include             : valğŸ›‘
  #   - include             : SğŸ›‘preâ¤

#â€”â€”â€” 2 Node Element: 3 Property
  âš¿â‚Œv-â¸™2:                 #âœ—â´
    - meta_scope          : meta.property.kdl #âœ—â´âš¿â‚Œvâ¸™
    - include             : ï¼ƒnon-keywordğŸ›‘
    - include             : keywordğŸ›‘
    - include             : ID_bareÂ¬1stğŸ›‘
    - include             : âš¿
  âš¿:                      #âœ—â´
    - match               : '({{charID}}+)'
      scope               : entity.other.attribute-name.kdl
      pop                 : 1 # â†‘â¸™
      push                :
        - meta_scope      : meta.property.name.kdl meta.mapping.key.kdl #âœ—â´
        - include         : nodeâ 
        - include         : propertyâ‚Œ
        - include         : pop_pre-term # unblock errors from spoiling the whole line

  # â€œâš¿â€â‚Œv-â¸™1:
  #   - meta_scope          : meta.property.name.kdl meta.mapping.key.kdl entity.other.attribute-name.kdl
  #   - include             : â€œâš¿â€
  â€œâš¿â€:
    - include             : strings # allows â†“ check to go through while 2nd consecutive string not possible since it'll be treated as a second argument and there is a condition that errors that
    - include             : nodeâ 
    - include             : propertyâ‚Œ
  propertyâ‚Œ:              #âœ—â´
    - match               : '(=)'
      scope               : meta.property.separator.kdl meta.mapping.separator.kdl punctuation.separator.key-value.kdl
      pop                 : 1
      push                : property-value # todo: set bugs to clear
  property-value:         #âœ—â´
    # - meta_scope          : # gets misapplied to =
    # - meta_content_scope  : # gets removed from some values that pop immediately like boolean #meta.property.value.kdl meta.mapping.value.kdl âœ—â´
    - include             : comments
    - match               : (?=\()
      pop                 : 2 # â†‘â¸™ to reach Â³ like arg_typed
      push                : #âœ—Â³
      - meta_scope        : meta.property.value.kdl meta.mapping.value.kdl #âœ—Â³prop_val_typ
      - include           : type-value
    - match               : (?!\() # required to apply proper context to value
      set                 : #âœ—â´
      - meta_scope        : meta.property.value.kdl meta.mapping.value.kdl #âœ—â´prop_val_untyp
      - include           : â„-ğŸ›‘
      - include           : value
      - include           : valueğŸ›‘
    - include             : propertyğŸ›‘
  # propertyğŸ›‘:
  #     - include           : pop_preâ 
  #     - include           : pop_preâ¤
  #     - include           : pop_preğŸ†”Â¬     # let previous layers deal with invalid chars
  #     - include           : chğŸ›‘preâ  # todo: or just scrap illegals? let unstyled content be the indicator
  #     - include           : SğŸ›‘preâ¤
  #     - include           : SğŸ›‘s

#â€”â€”â€” Type-values
  type-value:             #âœ—Â³
    - match               : \(
      scope               : punctuation.separator.annotation.begin.kdl
      push                : #âœ—â´
      - meta_scope        : meta.annotation.kdl #âœ—â´type_value
      - meta_content_scope: entity.name.type.kdl
      - match             : '(?<=\()(\))|(\))'
        captures          :
          1:                invalid.illegal.muted.kdl #punctuation.separator.annotation.end.kdl invalid.illegal.position.kdl
          2:                punctuation.separator.annotation.end.kdl
        pop               : 1 # remove â†‘annotation
        set               : # push bugs even with pop, still get meta_content
        - include         : nodeâ 
        - include         : value
        - include         : valueğŸ›‘
        - include         : pop2_pre-term # todo: sort which are best
        - include         : anyğŸ›‘s
      - include           : nodeâ 
      - include           : type-name
      - include           : typeğŸ›‘

  type-name:              #âœ—â´ see type-content-node
    - include             : keywordğŸ›‘
    - match               : '(?={{string_beg}})'
      push                : #âœ—âµ
      # - meta_scope        : dbgtype-nameâœ—âµ
      - include           : strings-quoted-double-raw-consecutiveğŸ›‘
      - include           : strings-quoted-double-consecutiveğŸ›‘
      - include           : strings
      - include           : pop_preï¼‰ # remove â†‘
      - include           : anyğŸ›‘s
    - include             : ID_bare_sğŸ›‘
  # # type-content: # fails due to the need to mandate 1value
  #   # - include             : keywordğŸ›‘
  #   # - include             : string
  #   # - include             : IDs_bare
  # typeğŸ›‘:
  #   - include             : charğŸ†”Â¬
  #   - include             : sğŸ›‘s
  #   - include             : SğŸ›‘s




  # IDs_bare:
  #   - match               : '({{bareID}})'
  # ID_bare:
  #   - match               : '({{bareID}})'
  #     pop                 : 1

#â€”â€”â€” Values - Keywords
  boolean:  #\b bugs with # since # isn't word border, so move # before \b
    - match               : \#\b(true|false)\b
      scope               : keyword.other.kdl constant.language.boolean.kdl
      pop                 : 2
  nil:
    - match               : '\#\b(null)\b'
      scope               : keyword.other.kdl constant.language.null.kdl
      pop                 : 2
  floatkw:  #\b bugs with -
    - match               : \#-?\b(inf)\b
      scope               : keyword.other.kdl constant.language.float.kdl
      pop                 : 2
    - match               : \#\b(nan)\b
      scope               : keyword.other.kdl constant.language.float.kdl
      pop                 : 2

  # before     sp begin
  # after  = ) sp end (though can't detect line continuation, add that condition within line cont rule)
  bool-partial: #\b bugs with n t|x
    - match               : '(?<={{pre_val}})\#(tr?u?|fa?l?s?)(?={{any_sp_t_beg}})'
      # scope               : dbgâœ—bool-partial punctuation.separator
      pop                 : 2
  null-partial:
    - match               : '(?<={{pre_val}})\#(nu?l?)(?={{any_sp_t_beg}})'
      pop                 : 2
  floatkw-partial:
    - match               : '(?<={{pre_val}})\#(-?in?)(?={{any_sp_t_beg}})'
      pop                 : 2
    - match               : '(?<={{pre_val}})\#(n?a)(?={{any_sp_t_beg}})'
      pop                 : 2

  bool-partial-extğŸ›‘: #\b bugs with n t|x   Invalid chars after valid keyword (even if partial)
    - match               : '(?<={{pre_val}})(\#)(tr?u?e?|fa?l?s?e?)({{charID_or_KW}}+)'
      # scope               : dbgâœ—bool_partial_extğŸ›‘ punctuation.separator
      captures            :
        3:                  invalid.illegal.position.kdl
      pop                 : 2
  null-partial-extğŸ›‘:  # remove 'n' match otherwise 'nan' will never get a chance
    - match               : '(?<={{pre_val}})(\#)(nul?l?)({{charID_or_KW}}+)'
      captures            :
        3:                  invalid.illegal.position.kdl
      pop                 : 2
  floatkw-partial-extğŸ›‘:
    - match               : '(?<={{pre_val}})(\#)(-?in?f?)({{charID_or_KW}}+)'
      captures            :
        3:                  invalid.illegal.position.kdl
      pop                 : 2
    - match               : '(?<={{pre_val}})(\#)(na?n?)({{charID_or_KW}}+)'
      captures            :
        3:                  invalid.illegal.position.kdl
      pop                 : 2

  ï¼ƒnon-keywordğŸ›‘: # in prop=val # isn't allowed, so no partial #tru included
    - match               : '(?=\#)'
      push                : #âœ—âµ
      # - meta_scope        : ï¼ƒnon-keywordğŸ›‘âœ—âµ
      - match             : '(\#)?({{charID_or_KW}})({{charID_or_KW}}*)'
        scope             : keyword.other.kdl
        captures          :
          1:               invalid.illegal.position.kdl
          2:               invalid.illegal.position.kdl
          3:               invalid.illegal.muted.position.kdl
        pop                 : 2
  ï¼ƒmaybe-keywordğŸ›‘:
    - match               : '(?=\#)'
      push                : #âœ—âµ
      # - meta_scope        : ï¼ƒmaybe-keywordğŸ›‘âœ—âµ
      - include           : keyword-partial-extğŸ›‘  # in arguments #t could be #true, so could #trued be a typo, thus don't error on partials, only on extends
      - match             : '(\#)?({{charID_or_KW}})({{charID_or_KW}}*)'
        scope             : keyword.other.kdl
        captures          :
          2:               invalid.illegal.position.kdl
          3:               invalid.illegal.muted.position.kdl
        pop                 : 2

  booleanğŸ›‘:
    - match               : '(\#)?((t)(rue)|(f)(alse))(?=[^{{charID}}])'
      scope               : keyword.other.kdl constant.language.boolean.kdl
      captures            :
        1:                 invalid.illegal.position.kdl
        3:                 invalid.illegal.position.kdl
        4:                 invalid.illegal.muted.position.kdl
        5:                 invalid.illegal.position.kdl
        6:                 invalid.illegal.muted.position.kdl
  nullğŸ›‘:
    - match               : '(\#)?((n)(ull))(?=[^{{charID}}])'
      scope               : keyword.other.kdl constant.language.null.kdl
      captures            :
        1:                 invalid.illegal.position.kdl
        3:                 invalid.illegal.position.kdl
        4:                 invalid.illegal.muted.position.kdl
  floatkwğŸ›‘:
    - match               : '(\#)?((-)?(i)(nf))(?=[^{{charID}}])'
      scope               : keyword.other.kdl constant.language.float.kdl
      captures            :
        1:                 invalid.illegal.position.kdl
        3:                 invalid.illegal.position.kdl
        4:                 invalid.illegal.position.kdl
        5:                 invalid.illegal.muted.position.kdl
    - match               : '(\#)?((n)(an))(?=[^{{charID}}])'
      scope               : keyword.other.kdl constant.language.float.kdl
      captures            :
        1:                 invalid.illegal.position.kdl
        3:                 invalid.illegal.position.kdl
        4:                 invalid.illegal.muted.position.kdl

  keyword1strğŸ›‘preâ ï¼›:    # to avoid red flashes, mark last char as illegal before â  or ; (rest muted)
    - match               : '((tru)(e)|(fals)(e)|(nul)(l)|(-?in)(f)|(na)(n))(?={{u_sp}}|;)'
      captures            :
        # 1:                  invalid.illegal.muted.position.kdl
        2:                  invalid.illegal.muted.position.kdl
        3:                  invalid.illegal.position.kdl
        4:                  invalid.illegal.muted.position.kdl
        5:                  invalid.illegal.position.kdl
        6:                  invalid.illegal.muted.position.kdl
        7:                  invalid.illegal.position.kdl
        8:                  invalid.illegal.muted.position.kdl
        9:                  invalid.illegal.position.kdl
        10:                 invalid.illegal.muted.position.kdl
        11:                 invalid.illegal.position.kdl
  keyword1nodeğŸ›‘preâ ï¼›:   # to avoid red flashes, mark last char as muted before â  or ; (rest node)
    - match               : '((tru)(e)|(fals)(e)|(nul)(l)|(-?in)(f)|(na)(n))(?={{u_sp}}|;|})'
      captures            :
        # 1:                  entity.name.tag.node.kdl
        2:                  entity.name.tag.node.kdl
        3:                  invalid.illegal.muted.position.kdl
        4:                  entity.name.tag.node.kdl
        5:                  invalid.illegal.muted.position.kdl
        6:                  entity.name.tag.node.kdl
        7:                  invalid.illegal.muted.position.kdl
        8:                  entity.name.tag.node.kdl
        9:                  invalid.illegal.muted.position.kdl
        10:                 entity.name.tag.node.kdl
        11:                 invalid.illegal.muted.position.kdl
      push                : #âœ—Â²
      - include           : node-elements
      - include           : SğŸ›‘s
  keyword1strğŸ›‘preâ¤:      # to avoid red flashes, mark last char as illegal before â¤ or ; (rest string)
    - match               : '((tru)(e)|(fals)(e)|(nul)(l)|(-?in)(f)|(na)(n))(?={{newline}})'
      captures            :
        2:                  meta.string.kdl string.unquoted.kdl
        3:                  invalid.illegal.muted.position.kdl
        4:                  meta.string.kdl string.unquoted.kdl
        5:                  invalid.illegal.muted.position.kdl
        6:                  meta.string.kdl string.unquoted.kdl
        7:                  invalid.illegal.muted.position.kdl
        8:                  meta.string.kdl string.unquoted.kdl
        9:                  invalid.illegal.muted.position.kdl
        10:                 meta.string.kdl string.unquoted.kdl
        11:                 invalid.illegal.muted.position.kdl
  keyword1nodeğŸ›‘preâ¤:     # to avoid red flashes, mark last char as illegal before â¤ or ; (rest node)
    - match               : '((tru)(e)|(fals)(e)|(nul)(l)|(-?in)(f)|(na)(n))(?={{newline}})'
      captures            :
        2:                  entity.name.tag.node.kdl
        3:                  invalid.illegal.muted.position.kdl
        4:                  entity.name.tag.node.kdl
        5:                  invalid.illegal.muted.position.kdl
        6:                  entity.name.tag.node.kdl
        7:                  invalid.illegal.muted.position.kdl
        8:                  entity.name.tag.node.kdl
        9:                  invalid.illegal.muted.position.kdl
        10:                 entity.name.tag.node.kdl
        11:                 invalid.illegal.muted.position.kdl
      push                : #âœ—Â²
      - include           : node-elements
      - include           : SğŸ›‘s



#â€”â€”â€” Values - Strings
  string-quoted-double:
    - match               : '(r?)(")'
      captures            :
        1:                  invalid.illegal.position.kdl
        2:                  punctuation.definition.string.begin.kdl
      push                :
      - meta_scope        : meta.string.kdl string.quoted.double.kdl
      - match             : '"'
        scope             : punctuation.definition.string.end.kdl
        pop               : 3
      - include           : char-escaped
      - include           : â¤ğŸ›‘Â¹s
  string-quoted-double3:
    - match               : '(r?)(""")({{nl_not_s}}?)({{nl_not_s}}*)'
      captures            :
        1:                  invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 invalid.illegal.position.kdl
        4:                 invalid.illegal.muted.position.kdl
      push                :
      - meta_scope        : meta.string.kdl string.quoted.double.block.kdl
      - match             : '^(({{u_sp}}|((\\)({{u_sp}}|{{newline}})+))*)({{u_sp_not}}?)([\s\S]*?)((?<!\\)""")'
      # - match             : '^((\s|\\\s+)*)([^\"]?)([^\"]*)((?<!\\)""")'
        captures          : # will only highlight the last \, don't know how to fix
          1:               whitespace.dedent.kdl
          3:               constant.character.escape.kdl
          4:               punctuation.definition.escape.begin.kdl
          6:               invalid.illegal.position.kdl
          7:               invalid.illegal.muted.position.kdl
          8:               punctuation.definition.string.end.kdl
        pop               : 3
      - include           : char-escaped
  strings-quoted-double:
    - match               : '(r?)(")'
      captures            :
        1:                  invalid.illegal.position.kdl
        2:                  punctuation.definition.string.begin.kdl
      push                :
      - meta_scope        : meta.string.kdl string.quoted.double.kdl
      - match             : '"'
        scope             : punctuation.definition.string.end.kdl
        pop               : 1
      - include           : char-escaped
      - include           : â¤ğŸ›‘Â¹s
  strings-quoted-double3:
    - match               : '(r?)(""")({{nl_not_s}}?)({{nl_not_s}}*)'
      captures            :
        1:                 invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 invalid.illegal.position.kdl
        4:                 invalid.illegal.muted.position.kdl
      push                :
      - meta_scope        : meta.string.kdl string.quoted.double.block.kdl
      - match             : '^(({{u_sp}}|((\\)({{u_sp}}|{{newline}})+))*)({{u_sp_not}}?)([\s\S]*?)(""")'
      # - match             : '^((\s|\\\s+)*)([^\"]?)([^\"]*)(""")'
        captures          : # will only highlight the last \, don't know how to fix
          1:               whitespace.dedent.kdl
          3:               constant.character.escape.kdl
          4:               punctuation.definition.escape.begin.kdl
          6:               invalid.illegal.position.kdl
          7:               invalid.illegal.muted.position.kdl
          8:               punctuation.definition.string.end.kdl
        pop               : 1
      - include           : char-escaped
  strings-quoted-double_node-id:
    - match               : '(r?)(")'
      captures            :
        1:                  invalid.illegal.position.kdl
        2:                  punctuation.definition.string.begin.kdl
      push                :
      - meta_scope        : entity.name.tag.node.kdl meta.string.kdl string.quoted.double.kdl
      - match             : '"'
        scope             : punctuation.definition.string.end.kdl
        pop               : 1
      - include           : char-escaped
      - include           : â¤ğŸ›‘Â¹s
  strings-quoted-double3_node-id:
    - match               : '(r?)(""")({{nl_not_s}}?)({{nl_not_s}}*)'
      captures            :
        1:                 invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 invalid.illegal.position.kdl
        4:                 invalid.illegal.muted.position.kdl
      push                :
      - meta_scope        : entity.name.tag.node.kdl meta.string.kdl string.quoted.double.block.kdl
      - match             : '^(({{u_sp}}|((\\)({{u_sp}}|{{newline}})+))*)({{u_sp_not}}?)([\s\S]*?)(""")'
      # - match             : '^((\s|\\\s+)*)([^\"]?)([^\"]*)(""")'
        captures          : # will only highlight the last \, don't know how to fix
          1:               whitespace.dedent.kdl
          3:               constant.character.escape.kdl
          4:               punctuation.definition.escape.begin.kdl
          6:               invalid.illegal.position.kdl
          7:               invalid.illegal.muted.position.kdl
          8:               punctuation.definition.string.end.kdl
        pop               : 1
      - include           : char-escaped
  char-escaped:
    - match               : '(\\)'
      scope               : constant.character.escape.kdl punctuation.definition.escape.begin.kdl
      push                :
      - match             : '({{esc_char_s}})'
        captures          :
          1:               constant.character.escape.kdl
        pop               : 1
      - include           : char-esc-uniğŸ›‘
      - include           : char-esc-uni
      - include           : uâ â¤s
      - include           : anyğŸ›‘
  char-esc-uni:
    - match               : '(u)({)({{d_hex}}{1,6})(})'
      captures            :
        1:                 constant.character.escape.utf8.hex.kdl
        2:                 constant.character.escape.utf8.hex.kdl punctuation.definition.usv.begin.kdl
        3:                 constant.character.escape.utf8.hex.kdl
        4:                 constant.character.escape.utf8.hex.kdl punctuation.definition.usv.end.kdl
      pop                 : 1
  char-esc-uniğŸ›‘:
      - match             : '(u)({)({{codepoint_not_hex}})(})'
        captures          :
          1:               constant.character.escape.utf8.hex.kdl
          2:               constant.character.escape.utf8.hex.kdl punctuation.definition.usv.begin.kdl
          3:               constant.character.escape.utf8.hex.kdl invalid.illegal.muted.position.kdl #ğŸ›‘codepoint_not_hex
          4:               constant.character.escape.utf8.hex.kdl punctuation.definition.usv.end.kdl
        pop               : 1
      - match             : '(u)({)({{usv_not_hex}})(})'
        captures          :
          1:               constant.character.escape.utf8.hex.kdl
          2:               constant.character.escape.utf8.hex.kdl punctuation.definition.usv.begin.kdl
          3:               constant.character.escape.utf8.hex.kdl invalid.illegal.muted.position.kdl #ğŸ›‘usv_not_hex
          4:               constant.character.escape.utf8.hex.kdl punctuation.definition.usv.end.kdl
        pop               : 1

  string-quoted-double-raw:
    - match               : '(r?)(#*)(")'
      captures            :
        1:                 invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 punctuation.definition.string.begin.kdl
      push                :
      - meta_scope        : meta.string.kdl string.quoted.double.raw.kdl
      - match             : '"\2' # â†‘match (#*)
        scope             : punctuation.definition.string.end.kdl
        pop               : 3
      - include           : â¤ğŸ›‘Â¹s
  string-quoted-double3-raw:
    - match               : '(r?)(#*)(""")({{nl_not_s}}?)({{nl_not_s}}*)'
      captures            :
        1:                 invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 punctuation.definition.string.begin.kdl
        4:                 invalid.illegal.position.kdl
        5:                 invalid.illegal.muted.position.kdl
      push                :
      - meta_scope        : meta.string.kdl string.quoted.double.block.raw.kdl
      - match             : '^(({{u_sp}}|((\\)({{u_sp}}|{{newline}})+))*)({{u_sp_not}}?)([\s\S]*?)(""")(\2)' # â†‘match (#*)
      # - match             : '^((\s|\\\s+)*)([^\"]?)([^\"]*)(""")'
        captures          : # will only highlight the last \, don't know how to fix
          1:               whitespace.dedent.kdl
          3:               constant.character.escape.kdl
          4:               punctuation.definition.escape.begin.kdl
          6:               invalid.illegal.position.kdl
          7:               invalid.illegal.muted.position.kdl
          8:               punctuation.definition.string.end.kdl
          9:               punctuation.definition.string.end.kdl
        pop               : 3
  strings-quoted-double-raw:
    - match               : '(r?)(#*)(")'
      captures            :
        1:                 invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 punctuation.definition.string.begin.kdl
      push                :
      - meta_scope        : meta.string.kdl string.quoted.double.raw.kdl
      - match             : '"\2' # â†‘match (#*)
        scope             : punctuation.definition.string.end.kdl
        pop               : 1
      - include           : â¤ğŸ›‘Â¹s
  strings-quoted-double3-raw:
    - match               : '(r?)(#*)(""")({{nl_not_s}}?)({{nl_not_s}}*)'
      captures            :
        1:                 invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 punctuation.definition.string.begin.kdl
        4:                 invalid.illegal.position.kdl
        5:                 invalid.illegal.muted.position.kdl
      push                :
      - meta_scope        : meta.string.kdl string.quoted.double.block.raw.kdl
      - match             : '^(({{u_sp}}|((\\)({{u_sp}}|{{newline}})+))*)({{u_sp_not}}?)([\s\S]*?)(""")(\2)' # â†‘match (#*)
      # - match             : '^((\s|\\\s+)*)([^\"]?)([^\"]*)(""")'
        captures          : # will only highlight the last \, don't know how to fix
          1:               whitespace.dedent.kdl
          3:               constant.character.escape.kdl
          4:               punctuation.definition.escape.begin.kdl
          6:               invalid.illegal.position.kdl
          7:               invalid.illegal.muted.position.kdl
          8:               punctuation.definition.string.end.kdl
          9:               punctuation.definition.string.end.kdl
        pop               : 1
  strings-quoted-double-raw_node-id:
    - match               : '(r?)(#*)(")'
      captures            :
        1:                 invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 punctuation.definition.string.begin.kdl
      push                :
      - meta_scope        : entity.name.tag.node.kdl meta.string.kdl string.quoted.double.raw.kdl
      - match             : '"\2' # â†‘match (#*)
        scope             : punctuation.definition.string.end.kdl
        pop               : 1
      - include           : â¤ğŸ›‘Â¹s
  strings-quoted-double3-raw_node-id:
    - match               : '(r?)(#*)(""")({{nl_not_s}}?)({{nl_not_s}}*)'
      captures            :
        1:                 invalid.illegal.position.kdl
        2:                 punctuation.definition.string.begin.kdl
        3:                 punctuation.definition.string.begin.kdl
        4:                 invalid.illegal.position.kdl
        5:                 invalid.illegal.muted.position.kdl
      push                :
      - meta_scope        : entity.name.tag.node.kdl meta.string.kdl string.quoted.double.block.raw.kdl
      - match             : '^(({{u_sp}}|((\\)({{u_sp}}|{{newline}})+))*)({{u_sp_not}}?)([\s\S]*?)(""")(\2)' # â†‘match (#*)
      # - match             : '^((\s|\\\s+)*)([^\"]?)([^\"]*)(""")'
        captures          : # will only highlight the last \, don't know how to fix
          1:               whitespace.dedent.kdl
          3:               constant.character.escape.kdl
          4:               punctuation.definition.escape.begin.kdl
          6:               invalid.illegal.position.kdl
          7:               invalid.illegal.muted.position.kdl
          8:               punctuation.definition.string.end.kdl
          9:               punctuation.definition.string.end.kdl
        pop               : 1
  # strings-quoted-double-consecutiveğŸ›‘: #
  #   - match               : '((?<=#)|(?<="))(")([^"]*")'
  #     captures            :
  #       2:                 invalid.illegal.position.kdl #âœ—â€â€œâ€s
  #       3:                 invalid.illegal.muted.position.kdl #âœ—â€â€œâ€s
  #   - match               : '((?<=#)|(?<="))(")([{{u_sp}}\S]*)'
  #     captures            :
  #       2:                 invalid.illegal.position.kdl #âœ—â€â€œs
  #       3:                 invalid.illegal.muted.position.kdl #âœ—â€â€œs
  # string-quoted-double-consecutiveğŸ›‘3: #
  #   - match               : '((?<=#)|(?<="))(")([^"]*")'
  #     captures            :
  #       2:                 invalid.illegal.position.kdl #âœ—â€â€œâ€3
  #       3:                 invalid.illegal.muted.position.kdl #âœ—â€â€œâ€3
  #     push                :
  #     - include           : pop3
  #   - match               : '((?<=#)|(?<="))(")([{{u_sp}}\S]*)'
  #     captures            :
  #       2:                 invalid.illegal.position.kdl #âœ—â€â€œ3
  #       3:                 invalid.illegal.muted.position.kdl #âœ—â€â€œ3
  #     push                :
  #     - include           : pop3
  # string-quoted-double-consecutiveğŸ›‘4:
  #   - match               : '((?<=#)|(?<="))(")([^"]*")'
  #     captures            :
  #       2:                 invalid.illegal.position.kdl #âœ—â€â€œâ€4
  #       3:                 invalid.illegal.muted.position.kdl #âœ—â€â€œâ€4
  #     push                :
  #     - include           : pop4
  #   - match               : '((?<=#)|(?<="))(")([{{u_sp}}\S]*)'
  #     captures            :
  #       2:                 invalid.illegal.position.kdl #âœ—â€â€œ4
  #       3:                 invalid.illegal.muted.position.kdl #âœ—â€â€œ4
  #     push                :
  #     - include           : pop4
  strings-quoted-double-raw-consecutiveğŸ›‘:
    - match               : '((?<=#)|(?<="))((?<h>#*)\")([\S\s]*?)(\"\k<h>)'
      captures            :
        2:                 invalid.illegal.position.kdl #âœ—â€râ€œâ€s
        4:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œâ€s
        5:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œâ€s
    - match               : '((?<=#)|(?<="))(#*)(")([{{u_sp}}\S]*)'
      captures            :
        2:                 invalid.illegal.position.kdl #âœ—â€râ€œs
        3:                 invalid.illegal.position.kdl #âœ—â€râ€œs
        4:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œs
  string-quoted-double-raw-consecutiveğŸ›‘3:
    - match               : '((?<=#)|(?<="))((?<h>#*)\")([\S\s]*?)(\"\k<h>)'
      captures            :
        2:                 invalid.illegal.position.kdl #âœ—â€râ€œâ€3
        4:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œâ€3
        5:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œâ€3
      push                :
      - include           : pop3
    - match               : '((?<=#)|(?<="))(#*)(")([{{u_sp}}\S]*)'
      captures            :
        2:                 invalid.illegal.position.kdl #âœ—â€râ€œ3
        3:                 invalid.illegal.position.kdl #âœ—â€râ€œ3
        4:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œ3
      push                :
      - include           : pop3
  string-quoted-double-raw-consecutiveğŸ›‘4:
    - match               : '((?<=#)|(?<="))((?<h>#*)\")([\S\s]*?)(\"\k<h>)'
      captures            :
        2:                 invalid.illegal.position.kdl #âœ—â€râ€œâ€4
        4:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œâ€4
        5:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œâ€4
      push                :
      - include           : pop4
    - match               : '((?<=#)|(?<="))(#*)(")([{{u_sp}}\S]*)'
      captures            :
        2:                 invalid.illegal.position.kdl #âœ—â€râ€œ4
        3:                 invalid.illegal.position.kdl #âœ—â€râ€œ4
        4:                 invalid.illegal.muted.position.kdl #âœ—â€râ€œ4
      push                :
      - include           : pop4
  # bare-after-stringğŸ›‘: #
  #   - match               : '((?<=#)|(?<="))({{bareID}})([{{u_sp}}\S]*)'
  #     captures            :
  #       2:                 invalid.illegal.position.kdl #âœ—â€bare
  #       6:                 invalid.illegal.muted.position.kdl #âœ—â€bare
  #     push                :
  #     - include           : pop3
  # bare-after-stringğŸ›‘4:
  #   - match               : '((?<=#)|(?<="))({{bareID}})([{{u_sp}}\S]*)'
  #     captures            :
  #       2:                 invalid.illegal.position.kdl #âœ—â€bare
  #       6:                 invalid.illegal.muted.position.kdl #âœ—â€bare
  #     push                :
  #     - include           : pop4


#â€”â€”â€” Values - Numbers
  # intâˆ¨decâˆ¨float:
  #   - match               : '([+-])?([0-9])' # leading zeros are allowed
  #     captures            :
  #       1:                  keyword.operator.arithmetic.kdl
  #     branch_point        : â¸™intâˆ¨decâˆ¨float
  #     branch              :
  #       - integerâ¸™        # Integer literal
  #       - decimalâ¸™        # Floating point literal (fraction)
  #       - floatâ¸™          # Floating point literal (exponent)
  # failâ¸™intâˆ¨decâˆ¨float-.:
  #   - match               : '\.'
  #     fail                : â¸™intâˆ¨decâˆ¨float
  # failâ¸™intâˆ¨decâˆ¨float-â„¯:
  #   - match               : '[eE]'
  #     fail                : â¸™intâˆ¨decâˆ¨float
  # integerâ¸™:
  #   - meta_scope          : constant.numeric.value.kdl constant.numeric.integer.kdl
  #   - include             : failâ¸™intâˆ¨decâˆ¨float-.
  #   - include             : failâ¸™intâˆ¨decâˆ¨float-â„¯
  #   - include             : digitâ‚â‚€_
  #   - include             : pop3â¸™
  # decimalâ¸™:                                       # Floating point literal (fraction)
  #   - meta_scope          : constant.numeric.value.kdl constant.numeric.decimal.kdl
  #   - include             : failâ¸™intâˆ¨decâˆ¨float-â„¯
  #   - include             : digitâ‚â‚€_
  #   - match               : '(\.)'
  #     scope               : punctuation.separator.decimal.kdl
  #     push                :
  #     - include           : failâ¸™intâˆ¨decâˆ¨float-â„¯
  #     - include           : digitâ‚â‚€_
  #     - include           : pop4
  #   - include             : pop3â¸™
  # floatâ¸™:                                         # Floating point literal (exponent)
  #   - meta_scope          : constant.numeric.value.kdl constant.numeric.float.kdl constant.numeric.significand.kdl
  #   - include             : digitâ‚â‚€_
  #   - include             : floatï¼
  #   - include             : floatâ„¯partial
  #   - include             : floatâ„¯
  #   - include             : pop3â¸™
  # floatï¼:
  #   - match               : '(\.)'
  #     scope               : punctuation.separator.decimal.kdl
  #     push                :
  #     - include           : digitâ‚â‚€_
  #     - include           : pop
  # floatâ„¯partial:
  #   - match               : '([eE])([+-])?(?={{nl_s}})'
  #     captures            :
  #       1:                  punctuation.separator.exponent.kdl
  #       2:                  keyword.operator.arithmetic.kdl
  #     push                :
  #     - clear_scopes      : 1 # clear previous meta scope significand
  #     - meta_scope        : constant.numeric.exponent.kdl
  #     - include           : pop4
  # floatâ„¯:
  #   - match               : '([eE])([+-])?([0-9])'
  #     captures            :
  #       1:                  punctuation.separator.exponent.kdl
  #       2:                  keyword.operator.arithmetic.kdl
  #     push                :
  #     - clear_scopes      : 1 # clear previous meta scope significand
  #     - meta_scope        : constant.numeric.exponent.kdl
  #     - include           : digitâ‚â‚€_
  #     - include           : pop4

  # binary:                                         # Integer literal (binary)
  #   - match               : '(0b)(?=[0-1])'
  #     scope               : constant.numeric.base.kdl
  #     push                :
  #     - meta_scope        : constant.numeric.integer.binary.kdl
  #     - meta_content_scope: constant.numeric.value.kdl
  #     - include           : â„¤â‚‚
  # octal:                                          # Integer literal (octal)
  #   - match               : '(0o)(?=[0-7])'
  #     scope               : constant.numeric.base.kdl
  #     push                :
  #     - meta_scope        : constant.numeric.integer.octal.kdl
  #     - meta_content_scope: constant.numeric.value.kdl
  #     - include           : â„¤â‚ˆ
  # hexadecimal:                                    # Integer literal (hexadecimal)
  #   - match               : '(0x)(?=\h)'
  #     scope               : constant.numeric.base.kdl
  #     push                :
  #     - meta_scope        : constant.numeric.integer.hexadecimal.kdl
  #     - meta_content_scope: constant.numeric.value.kdl
  #     - include           : â„¤â‚â‚†

  # binÂ¦octÂ¦hex-partial:
  #   - include             : binary-partial
  #   - include             : octal-partial
  #   - include             : hexadecimal-partial
  # binary-partial:
  #   - match               : '(0b)(?={{nl_s}})'
  #     scope               : constant.numeric.base.kdl
  #     push                :
  #     - meta_scope        : constant.numeric.integer.binary.kdl
  #     - include           : pop5
  # octal-partial:
  #   - match               : '(0o)(?={{nl_s}})'
  #     scope               : constant.numeric.base.kdl
  #     push                :
  #     - meta_scope        : constant.numeric.integer.octal.kdl
  #     - include           : pop5
  # hexadecimal-partial:
  #   - match               : '(0x)(?={{nl_s}})'
  #     scope               : constant.numeric.base.kdl
  #     push                :
  #     - meta_scope        : constant.numeric.integer.hexadecimal.kdl
  #     - include           : pop5

  # Values - Numbers (helpers) digitâ‚â‚€_
  # can't match repeatable group in a regex, so repeat a single digit match
  # â„¤:
  #   - match               : '([0-9])' # leading zeros are allowed
  #     push                :
  #     - include           : digitâ‚â‚€_
  #     - include           : pop4
  # â„¤â‚‚:
  #   - match               : '([0-1])'
  #     push                :
  #     - include           : digitâ‚‚_
  #     - include           : pop4
  # â„¤â‚ˆ:
  #   - match               : '([0-7])'
  #     push                :
  #     - include           : digitâ‚ˆ_
  #     - include           : pop4
  # â„¤â‚â‚†:
  #   - match               : '(\h)'
  #     push                :
  #     - include           : digitâ‚â‚†_
  #     - include           : pop4
  # digitâ‚â‚€_:
  #   - match               : '(_)|([0-9])'
  #     captures            :
  #       1:                  punctuation.separator.number.kdl
  # digitâ‚‚_:
  #   - match               : '(_)|([0-1])'
  #     captures            :
  #       1:                  punctuation.separator.number.kdl
  # digitâ‚ˆ_:
  #   - match               : '(_)|([0-7])'
  #     captures            :
  #       1:                  punctuation.separator.number.kdl
  # digitâ‚â‚†_:
  #   - match               : '(_)|([0-9a-fA-F])'
  #     captures            :
  #       1:                  punctuation.separator.number.kdl


#â€”â€”â€” 2 Node Element: 4 Child
  # child_block:
  #   - match               : '{'
  #     scope               : punctuation.section.mapping.begin.kdl
  #     push                : child_block-body
  child_block3:
    - match               : '{'
      scope               : punctuation.section.mapping.begin.kdl
      push                : child_block3-body
  child_block1:
    - match               : '{'
      scope               : punctuation.section.mapping.begin.kdl
      push                : child_block1-body
  child_block_nofollow2:  # doesn't include following children blocks
    - match               : '{'
      scope               : punctuation.section.mapping.begin.kdl
      push                : child_block_nofollow2-body
  child_block6:
    - match               : '{'
      scope               : punctuation.section.mapping.begin.kdl #âœ—chblock4
      push                : child_block6-body
  child_block-body:
    - meta_scope          : meta.block.child.kdl
    - include             : wss
    - include             : comment_line_noâ¤
    - include             : ï½ch2t3
    - match               : '(?=\S)'
      push                : nodes
  child_block3-body:
    - meta_scope          : meta.block.child.kdl
    - include             : wss
    - include             : comment_line_noâ¤
    - include             : ï½ch1t3
    - match               : '(?=\S)'
      push                : nodes
  child_block1-body:
    - meta_scope          : meta.block.child.kdl
    - include             : wss
    - include             : comment_line_noâ¤
    - include             : ï½ch0t2
    - match               : '(?=\S)'
      push                : nodes
    # - include             : pop2
  child_block_nofollow2-body:
    - meta_scope          : meta.block.child.kdl
    - include             : wss
    - include             : comment_line_noâ¤
    - include             : ï½1t2nofolâ¸®
    - match               : '(?=\S)'
      push                : nodes
    # - include             : pop2
  child_block6-body:
    - meta_scope          : meta.block.child.kdl #âœ—chblock4_body
    - include             : wss
    - include             : comment_line_noâ¤
    - include             : ï½2t4
    - match               : '(?=\S)'
      push                : nodes


#â€”â€”â€” 2 Node Element: 5 End
  # node_terminator:        # node_end â‰ comment_line | â¤ | ï¼› | eof
  #   - include             : comment_line
  #   - include             : â¤
  #   - include             : eof
  #   # - include             : popï½
  #   - match               : ;
  #     scope               : punctuation.terminator.node.kdl
  #     pop                 : 1
  #   - include             : ï½ğŸ›‘
  # node_terminatorğŸ›‘2:
  #   - include             : comment_lineğŸ›‘2
  #   - include             : â¤ğŸ›‘2
  #   # - include             : eof
  #   - match               : ;
  #     scope               : invalid.illegal.position.kdl
  #     pop                 : 2
  #   - include             : ï½ğŸ›‘2
  # node_terminatorğŸ›‘3:
  #   - include             : comment_lineğŸ›‘3
  #   - include             : â¤ğŸ›‘3
  #   # - include             : eof
  #   - match               : ;
  #     scope               : invalid.illegal.position.kdl
  #     pop                 : 3
  #   - include             : ï½ğŸ›‘3
  # node_terminator2:       # X pops to allow the convenience of earlier pushes to e.g. track node level and ensure arguments have mandatory ws
  #   - include             : comment_line2_term
  #   - include             : â¤term2
  #   - include             : eof2
  #   - match               : ;
  #     scope               : punctuation.terminator.node.kdl
  #     pop                 : 2
  #   - include             : ï½ğŸ›‘2
  node_end3:
    - include             : comment_line3_term
    - include             : â¤term3
    - include             : eof3
    - match               : ;
      scope               : punctuation.terminator.node.kdl
      pop                 : 3
  node_end2:
    - include             : comment_line2_term
    - include             : â¤term2
    - include             : eof2
    - match               : ;
      scope               : punctuation.terminator.node.kdl
      pop                 : 2
  node_end: # node_end â‰ comment_line | â¤ | ï¼› | eof
    - include             : comment_line_term
    - include             : â¤term
    - include             : eof
    - match               : ;
      scope               : punctuation.terminator.node.kdl
      pop                 : 1
  node_terminator3:
    - include             : node_end3
    - include             : ï½ğŸ›‘3
  nodech_terminator3â¸®:
    - include             : node_end3
    - include             : pop3 # no terminator @ last child node not an error anymore
  nodech_terminator2:
    - include             : node_end2
    - include             : ï½ğŸ›‘2
  nodech_terminator2â¸®:
    - include             : node_end2
    - include             : pop2
  nodech_terminatorâ¸®:
    - include             : node_end
    - include             : pop
  nodech_terminator:
    - include             : node_end
    - include             : ï½ğŸ›‘
  # node_terminator4:
  #   - include             : comment_line4_term
  #   - include             : â¤term4
  #   - include             : eof4
  #   - match               : ;
  #     scope               : punctuation.terminator.node.kdl
  #     pop                 : 4
  #   - include             : ï½ğŸ›‘4

  ï½1t3:
    - match               : '}'
    # - match               : '}|(?<=})' # alternative to hunting down space} to highlight the missing ;
    # - match               : '}|(?!{{nl_s}})(?<=})' # better alternative to avoid end} breaking next }
      scope               : punctuation.section.mapping.end.kdl
      pop                 : 2
      push                :
      - include           : wss
      - include           : node_terminator3
      - include           : SğŸ›‘Â¹preâ¤
  ï½0t2:
    - match               : '}'
      scope               : punctuation.section.mapping.end.kdl
      pop                 : 1 # reset meta child scope
      push                :
      - include           : wss
      - include           : node_terminator2
      - include           : SğŸ›‘Â¹preâ¤
  ï½1t2nofolâ¸®:
    - match               : '}'
      scope               : meta.block.child.kdl punctuation.section.mapping.end.kdl
      pop                 : 2
      push                :
      - include           : wss
      - include           : nodech_terminator2â¸®
      - include           : SğŸ›‘Â¹preâ¤
  ï½ch0t2: # allows /-{ch} blocks to continue after the ending
    - match               : '}'
      scope               : meta.block.child.kdl punctuation.section.mapping.end.kdl
      pop                 : 1
      push                :
      - include           : wss
      - include           : node_end2
      - include           : node_childrenâ„-s
      - include           : pop2
  ï½ch1t3:
    - match               : '}'
      scope               : meta.block.child.kdl punctuation.section.mapping.end.kdl
      pop                 : 2
      push                :
      - include           : wss
      - include           : node_end3
      - include           : node_childrenâ„-s
      - include           : pop3
  ï½2t3:
    - match               : '}'
      scope               : punctuation.section.mapping.end.kdl
      pop                 : 3
      push                :
      - include           : wss
      - include           : node_terminator3
      - include           : SğŸ›‘Â¹preâ¤
  ï½ch2t3:
    - match               : '}'
      scope               : meta.block.child.kdl punctuation.section.mapping.end.kdl
      pop                 : 3
      push                :
      - include           : wss
      - include           : node_end3
      - include           : node_childrenâ„-s
      - include           : pop3
  ï½2t4:
    - match               : '}'
      scope               : punctuation.section.mapping.end.kdl
      pop                 : 3
      push                :
      - include           : wss
      - include           : node_terminator4
      - include           : SğŸ›‘Â¹preâ¤
  # preï½ğŸ›‘:                # missing node terminator before }, requires hunting down for space before }, which nodespace or other rule can handle already
  #   - match               : '{{u_sp}}*?({{u_sp}})?(?=\})'
  #     captures            :
  #       1:                  invalid.illegal.kdl
  #     pop                 : 1
  # ï½ğŸ›‘:
  #   - match               : '}'
  #     scope               : punctuation.section.mapping.end.kdl invalid.illegal.position.kdl #âœ—ï½ğŸ›‘
  #     pop                 : 1
  # ï½ğŸ›‘2:
  #   - match               : '}'
  #     scope               : punctuation.section.mapping.end.kdl invalid.illegal.position.kdl #âœ—ï½ğŸ›‘2
  #     pop                 : 2
  # ï½ğŸ›‘3:
  #   - match               : '}'
  #     scope               : punctuation.section.mapping.end.kdl invalid.illegal.position.kdl #âœ—ï½ğŸ›‘3
  #     pop                 : 3
  #     push                :
  #     - include           : wss
  #     - include           : node_terminator3
  #     - include           : SğŸ›‘Â¹preâ¤

  # ï½ğŸ›‘4:
  #   - match               : '}'
  #     scope               : punctuation.section.mapping.end.kdl invalid.illegal.position.kdl #âœ—ï½ğŸ›‘4
  #     pop                 : 4
  #     push                :
  #     - include           : wss
  #     - include           : node_terminator3
  #     - include           : SğŸ›‘Â¹preâ¤
  # ï½:
  #   - match               : '(?=\})'
  #     pop                 : 1
  # ï½2:
  #   - match               : '(?=\})'
  #     pop                 : 2
  # ï½3:
  #   - match               : '(?=\})'
  #     pop                 : 3
  # ï½4:
  #   - match               : '(?=\})'
  #     pop                 : 4

  # line_continuation:      # â‰ escline = \ ws* (single-line-comment     | newline)
  #                         #                  =â†‘single-line-comment_no_nl newline
  #   - match               : \\
  #     scope               : punctuation.separator.continuation.line.kdl #âœ—lc
  #     push                : line_continuation-line1
  # line_continuations:
  #   - match               : \\
  #     scope               : punctuation.separator.continuation.line.kdl #âœ—lcs
  #     push                : line_continuations-line1
  # line_continuation-line1:
  #   - include             : wss                         # â‰ ... ws*
  #   - include             : comment_line_noâ¤           # â‰ ... single-line-comment (without newline, so â†“ captures)
  #   - match               : '({{nl_s}})'                # â‰ ... newline
  #     #scope               : dbgâœ—line_continuation-line1
  #     set                 : line_continuation-line_next
  #   - include             : SğŸ›‘s
  # line_continuations-line1:
  #   #- meta_scope          : dbgâœ—line_continuations-line1
  #   # - include             : keyword-partial
  #   - include             : wss
  #   - include             : comment_line_noâ¤
  #   - match               : '({{nl_s}})'
  #     set                 : line_continuations-line_next
  #   - include             : SğŸ›‘s
  # line_continuation-line_next:
  #   - include             : wss
  #   - include             : comment_line_noâ¤
  #   - include             : â¤ğŸ›‘
  #   - match               : \\                          # disallows repeated
  #     scope               : punctuation.separator.continuation.line.kdl invalid.illegal.position.kdl
  #     # pop                 : 1                         # disallows 2nd \, but not 3rd+
  #   - include             : else-pop
  #   # - include             : else-pop2                   # 2 disallows repeated \, but requires extra push before use
  # line_continuations-line_next:
  #   - include             : wss
  #   - include             : comment_lines_noâ¤
  #   - include             : â¤ğŸ›‘s # todo: change to 1
  #   - include             : else-pop


#â€”â€”â€” Comments
  # comment_block_doc       :                       # Block documentation comment
  #   - match               : '({{comment_block_doc_beg}})'
  #     scope               : punctuation.definition.comment.begin.kdl
  #     push                :
  #     - meta_scope        : comment.block.documentation.kdl
  #     - match             : '{{comment_block_end}}'
  #       scope             : punctuation.definition.comment.end.kdl
  #       pop               : 1
  #     - include           : comment_block_doc
  #     - include           : comment_block
  # comment_block           :                       # Block comment
  #   - match               : '({{comment_block_beg}})'
  #     scope               : punctuation.definition.comment.begin.kdl
  #     push                :
  #     - meta_scope        : comment.block.kdl
  #     - match             : '{{comment_block_end}}'
  #       scope             : punctuation.definition.comment.end.kdl
  #       pop               : 1
  #     - include           : comment_block_doc
  #     - include           : comment_block
  # comment_line:                                   # Single-line comment
  #   - match               : // # better than {{comment_line}} as doesn't consume the whole line and allows embedding with early popping
  #     scope               : punctuation.definition.comment.begin.kdl
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $({{newline}})? # consume â¤ not to show completions when typing comments
  #         pop             : 2
  #         captures        :
  #           1:              punctuation.definition.comment.end.kdl
  # comment_lineğŸ›‘:
  #   - match               : //
  #     scope               : invalid.illegal.position.kdl
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $({{newline}})?
  #         pop             : 2
  #         captures        :
  #           1:              punctuation.definition.comment.end.kdl
  # comment_lineğŸ›‘2:
  #   - match               : //
  #     scope               : invalid.illegal.position.kdl
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $({{newline}})?
  #         pop             : 3
  #         captures        :
  #           1:              punctuation.definition.comment.end.kdl
  # comment_lineğŸ›‘3:
  #   - match               : //
  #     scope               : invalid.illegal.position.kdl
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $({{newline}})?
  #         pop             : 4
  #         captures        :
  #           1:              punctuation.definition.comment.end.kdl
  comment_line_term:      #âœ—
    - match               : //
      scope               : punctuation.definition.comment.begin.kdl punctuation.terminator.node.kdl
      push                :    #â†’âœ—+1
        - meta_scope      : comment.line.double-slash.kdl
        - match           : $({{newline}})?
          pop             : 2 #â†’âœ—
          captures        :
            1:              punctuation.definition.comment.end.kdl
  # comment_line2_term:
  #   - match               : //
  #     scope               : punctuation.definition.comment.begin.kdl punctuation.terminator.node.kdl
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $({{newline}})?
  #         pop             : 3
  #         captures        :
  #           1:              punctuation.definition.comment.end.kdl
  # comment_line3_term:
  #   - match               : //
  #     scope               : punctuation.definition.comment.begin.kdl punctuation.terminator.node.kdl
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $({{newline}})?
  #         pop             : 4
  #         captures        :
  #           1:              punctuation.definition.comment.end.kdl
  # comment_line4_term:
  #   - match               : //
  #     scope               : punctuation.definition.comment.begin.kdl punctuation.terminator.node.kdl
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $({{newline}})?
  #         pop             : 5
  #         captures        :
  #           1:              punctuation.definition.comment.end.kdl
  # comment_line_noâ¤:                             # Single-line comment without capturing ending â¤
  #   - match               : //
  #     scope               : punctuation.definition.comment.begin.kdl #âœ—cline_noâ¤
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $
  #         pop             : 1
  # comment_line2_noâ¤:
  #   - match               : //
  #     scope               : punctuation.definition.comment.begin.kdl #âœ—cline_noâ¤
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $
  #         pop             : 2
  # comment_lines_noâ¤:
  #   - match               : //
  #     scope               : punctuation.definition.comment.begin.kdl #âœ—cline_noâ¤
  #     push                :
  #       - meta_scope      : comment.line.double-slash.kdl
  #       - match           : $
  #         pop             : 1


# Primitives, with some ~matching KDL Spec elements
  linesp:                 #l_â  â‰ nâ |â¤|comment_line
    - include             : â¤
    - include             : nodeâ 
    - include             : comment_line #todo: bugs with } on a line after //
    # - include             : comment_line_noâ¤
  uâ â¤s:   # Regular and line breaking whitespace
    - match               : '({{uspnl}})'
      scope               : whitespace.escape.kdl
      push                : # to "glue" contiguous spaces together with the same scope
      - match             : '({{uspnl}})'
        scope             : whitespace.escape.kdl
      - include           : else-pop2
  # â¤s:
  #   - match               : '{{newline}}'
  #     #scope               : dbgâœ—â¤s
  # â¤:
  #   - match               : '{{newline}}'
  #     #scope               : dbgâœ—â¤
  #     pop                 : 1
  â¤term:
    - match               : '{{newline}}'
      scope               : punctuation.terminator.node.kdl #âœ—â¤1
      pop                 : 1
  # â¤term2:
  #   - match               : '{{newline}}'
  #     scope               : punctuation.terminator.node.kdl #âœ—â¤2
  #     pop                 : 2
  # â¤term3:
  #   - match               : '{{newline}}'
  #     scope               : punctuation.terminator.node.kdl #âœ—â¤3
  #     pop                 : 3
  # â¤term4:
  #   - match               : '{{newline}}'
  #     scope               : punctuation.terminator.node.kdl #âœ—â¤4
  #     pop                 : 4
  # eof:
  #   - match               : '{{eof}}'
  #     #scope               : dbgâœ—eof
  #     pop                 : 1
  # eof2:
  #   - match               : '{{eof}}'
  #     #scope               : dbgâœ—eof
  #     pop                 : 2
  # eof3:
  #   - match               : '{{eof}}'
  #     #scope               : dbgâœ—eof
  #     pop                 : 3
  # eof4:
  #   - match               : '{{eof}}'
  #     #scope               : dbgâœ—eof
  #     pop                 : 4

  ws:                     # â‰ unicode-space | multi-line-comment
    - include             : u_sp
    - include             : comment_blockâˆ¨doc
  wss:
    - include             : u_sps
    - include             : comment_blockâˆ¨doc
  # bom:
  #   - match               : '{{bom}}'
  #     #scope               : dbgâœ—bom
  #     pop                 : 1
  # boms:
  #   - match               : '{{bom}}'
  #     #scope               : dbgâœ—boms
  # u_sp:
  #   - match               : '{{u_sp}}'
  #     #scope               : dbgâœ—â 
  #     pop                 : 1
  # u_sps:
  #   - match               : '{{u_sp}}'
  #     #scope               : dbgâœ—â s

  # nodeâ :                 # â‰ node-space: ws* escline ws* | ws+
  #   - include             : line_continuation
  #   - include             : ws+âˆ¨ws-lineâ‹-ws
  # nodeâ s:
  #   - include             : line_continuations
  #   - include             : wss # todo: don't need branching?
  # nodeâ â„-:                #
  #   - include             : line_continuationâ„-
  #   - include             : ws+âˆ¨ws-lineâ‹-ws
  # ws+âˆ¨ws-lineâ‹-ws:
  #   - match               : '(?={{ws_beg}})'
  #     branch_point        : â¸™ws+âˆ¨ws-lineâ‹-ws
  #     branch              :
  #       - ws+â¸™1
  #       - ws-lineâ‹-wsâ¸™1
  # ws+âˆ¨ws-lineâ‹-wsâ„-:
  #   - match               : '(?={{ws_beg}})'
  #     branch_point        : â¸™ws+âˆ¨ws-lineâ‹-wsâ„-
  #     branch              :
  #       - ws+â„-â¸™1
  #       - ws-lineâ‹-wsâ„-â¸™1
  # ws+â¸™1:
  #   #- meta_scope          : dbgâœ—nodeâ _ws+âˆ¨ws-lineâ‹-ws_ws+â¸™1
  #   - match               : '(?={{escline_beg}})'
  #     fail                : â¸™ws+âˆ¨ws-lineâ‹-ws
  #   - include             : wss
  #   - include             : popâ¸™
  #   # - meta_scope          : âœ—ws+â¸™1
  #   # - match               : '{{u_sp}}'
  #     # scope               : bspâœ—ws+â¸™1
  #   # - include             : comment_blockâˆ¨doc
  #   # - include             : node-elements
  #   # - match               : '(?={{ws_beg}})'
  #     # push                :
  #     # - include           : ws-pop2
  #   # - include             : anyğŸ›‘
  # ws+â„-â¸™1:
  #   - match               : '(?={{escline_beg}})'
  #     fail                : â¸™ws+âˆ¨ws-lineâ‹-wsâ„-
  #   - include             : wss
  #   - include             : popâ¸™
  # ws-lineâ‹-wsâ¸™1:
  #   - include             : wss
  #   - include             : line_continuation
  #   - include             : popâ¸™
  #   # - meta_scope          : âœ—ws-lineâ‹-wsâ¸™1
  #   # - match               : '{{u_sp}}'
  #   #   scope               : bspâœ—ws-lineâ‹-wsâ¸™1
  #   # - include             : comment_blockâˆ¨doc
  # ws-lineâ‹-wsâ„-â¸™1:
  #   - include             : wss
  #   - include             : line_continuationâ„-
  #   - include             : popâ¸™
  # nodeâ +:
  #   - include             : nodeâ 
  #   - include             : anyğŸ›‘



# Various helpers
  chğŸ›‘s:
    - match               : '{{char_illegal}}'
      scope               : invalid.illegal.kdl
  chğŸ›‘:
    - match               : '{{char_illegal}}'
      scope               : invalid.illegal.kdl
      pop                 : 1
  # â¤ğŸ›‘s:
  #   - match               : '{{nl_s}}'
  #     scope               : invalid.illegal.position.kdl #âœ—delnl
  # â¤ğŸ›‘:
  #   - match               : '{{nl_s}}'
  #     scope               : invalid.illegal.position.kdl #âœ—delnl1
  #     pop                 : 1
  # â¤ğŸ›‘2:
  #   - match               : '{{nl_s}}'
  #     scope               : invalid.illegal.position.kdl #âœ—delnl2
  #     pop                 : 2
  # â¤ğŸ›‘3:
  #   - match               : '{{nl_s}}'
  #     scope               : invalid.illegal.position.kdl #âœ—delnl3
  #     pop                 : 3
  # â¤ğŸ›‘Â¹s:                 # make only the first contiguous â¤ red
  #   - match               : '({{nl_s}})'
  #     scope               : invalid.illegal.position.kdl #âœ—1
  #     push                :
  #     - match             : '({{nl_s}})'
  #       scope             : invalid.illegal.muted.position.kdl #âœ—1b
  #     - include           : else-pop
  # anyğŸ›‘s:
  #   - match               : '[\S\s]'
  #     scope               : invalid.illegal.position.kdl #âœ—DelAnyğŸ›‘s
  # anyğŸ›‘:
  #   - match               : '[\S\s]'
  #     scope               : invalid.illegal.position.kdl #âœ—DelAnyğŸ›‘
  #     pop                 : 1
  # sğŸ›‘Â¹:                   # make only the first contiguous \s red
  #   - match               : '(\s)'
  #     scope               : invalid.illegal.position.kdl #âœ—sğŸ›‘Â¹s
  #     push                :
  #     - match             : '(\s)'
  #       scope             : invalid.illegal.muted.position.kdl #âœ—sğŸ›‘Â¹s
  #       pop               : 2    # bail out after 2nd space
  #     - include           : pop2 # bail out after 1st space
  # sğŸ›‘Â¹s:                  # make only the first contiguous \s red
  #   - match               : '(\s)'
  #     scope               : invalid.illegal.position.kdl #âœ—sğŸ›‘Â¹s
  #     push                :
  #     - match             : '(\s)'
  #       scope             : invalid.illegal.muted.position.kdl #âœ—sğŸ›‘Â¹s
  #     - include           : pop # repeat 2nd space
  # bspğŸ›‘Â¹s:                  # make only the first contiguous u_sp red
  #   - match               : '({{u_sp}})'
  #     scope               : invalid.illegal.position.kdl #âœ—bspğŸ›‘Â¹s
  #     push                :
  #     - match             : '({{u_sp}})'
  #       scope             : invalid.illegal.muted.position.kdl #âœ—bspğŸ›‘Â¹s
  #     - include           : pop # repeat 2nd space
  # sğŸ›‘s:
  #   - match               : '(\s)'
  #     scope               : invalid.illegal.position.kdl #âœ—2
  # sğŸ›‘:
  #   - match               : '(\s)'
  #     scope               : invalid.illegal.position.kdl #âœ—3
  #   - include             : else-pop
  # SğŸ›‘s:
  #   - match               : '(\S)'
  #     scope               : invalid.illegal.position.kdl #âœ—SğŸ›‘
  # SğŸ›‘:
  #   - match               : '(\S)'
  #     scope               : invalid.illegal.position.kdl #âœ—SğŸ›‘
  #     pop                 : 1
  # SğŸ›‘preâ :               # mark without red highlight
  #   - match               : '(\S*)(?={{u_sp}})'
  #     captures            :
  #       2:                  invalid.illegal.muted.position.kdl #âœ—SğŸ›‘preâ 
  chğŸ›‘preâ :              # to avoid red flashes, mark last char as illegal before â 
    - match               : '({{charID_or_KW}}*)({{charID_or_KW}})(?={{u_sp}})'
      captures            :
        1:                  invalid.illegal.muted.position.kdl #âœ—chğŸ›‘preâ 
        2:                  invalid.illegal.position.kdl #âœ—chğŸ›‘preâ 
  # chğŸ›‘pre-str:
  #   - match               : '({{charID}}*?)({{charID}})(?={{string_beg}})'
  #     captures            :
  #       1:                  invalid.illegal.muted.position.kdl #âœ—chğŸ›‘pre-str
  #       2:                  invalid.illegal.position.kdl #âœ—chğŸ›‘pre-str
  # chğŸ›‘pre_term:           # to avoid red flashes, mark last char as illegal before node terminator
  #   - match               : '({{charID}}*)({{charID}})(?={{node_term_beg_no_nl}})'
  #     captures            :
  #       1:                  invalid.illegal.muted.position.kdl #âœ—chğŸ›‘pre_term
  #       2:                  invalid.illegal.position.kdl #âœ—chğŸ›‘pre_term
  # SğŸ›‘preâ¤:               # to avoid red flashes, mark as invalid, not illegal
  #   - match               : '(\S*)(\S)(?=\n)'
  #     captures            :
  #       1:                  invalid.illegal.muted.position.kdl
  #       2:                  invalid.illegal.muted.position.kdl
  # SğŸ›‘Â¹preâ¤:              # make only the first char before â¤ red
  #   - match               : '(\S)'
  #     scope               : invalid.illegal.position.kdl #âœ—SğŸ›‘Â¹preâ¤
  #     push                :
  #     - include           : pop_preâ¤
  #     - match             : '(\S)'
  #       scope             : invalid.illegal.muted.position.kdl #âœ—SğŸ›‘Â¹preâ¤
  # SğŸ›‘Â¹pre_ws:             # ... â  â¤
  #   - match               : '(\S)'
  #     scope               : invalid.illegal.position.kdl #âœ—SğŸ›‘Â¹preâ¤
  #     push                :
  #     - include           : pop_preâ 
  #     - include           : pop_preâ¤
  #     - match             : '(\S)'
  #       scope             : invalid.illegal.muted.position.kdl #âœ—SğŸ›‘Â¹preâ¤
  # SğŸ›‘Â¹pre_sâˆ¨câˆ¨t:          # ... child start or node terminator or ws
  #   - match               : '(\S)'
  #     scope               : invalid.illegal.position.kdl #âœ—SğŸ›‘Â¹pre_sâˆ¨câˆ¨t
  #     push                :
  #     - include           : pop_pre-ch
  #     - include           : pop_pre-term
  #     - include           : pop_pre-nodeâ 
  #     - match             : '(\S)'
  #       scope             : invalid.illegal.muted.position.kdl #âœ—SğŸ›‘Â¹pre_sâˆ¨câˆ¨t


  # charğŸ†”Â¬:
  #   - match               : '{{charID_not}}'
  #     scope               : invalid.illegal.kdl #âœ—chID
  ID_bareÂ¬1stğŸ›‘:
    # - match               : '({{charID_not1st}})'
    - match               : '(?<!=){{charID_not1st}}' # K=V lookbehind prevents matching V after K fails
      captures            : # charID_not1st has 2 groups inside
        1:                  invalid.illegal.position.kdl
        2:                  invalid.illegal.position.kdl
        3:                  invalid.illegal.muted.position.kdl
      # pop                 : 1 # alternative without lookbehind, but this resets = to node, so worse?
  ID_bare_sğŸ›‘: # bans anything except nodeâ  or closing ) after bareID has begun
    - match               : '({{bareID}})'
      push:
      - match             : '(?=\))'
        pop               : 1
      - include           : nodeâ 
      - match             : '([^\)])([^\)]*)'
        captures          :
          1:                invalid.illegal.position.kdl
          2:                invalid.illegal.muted.position.kdl
        # pop               : 1

  # pop_preâ :
  #   - match               : '(?={{u_sp}})'
  #     pop                 : 1
  # pop_pre-ch:
  #   - match               : '(?=\{)'
  #     pop                 : 1
  # pop_pre-term:
  #   - match               : '(?={{node_term_beg}})'
  #     pop                 : 1
  # pop_preâ¤:
  #   - match               : '(?={{nl_s}})'
  #     pop                 : 1
  # pop_pre-nodeâ :
  #   - match               : '(?={{node_sp_beg}})'
  #     pop                 : 1
  # pop_preğŸ†”Â¬:
  #   - match               : '(?={{charID_not}})'
  #     pop                 : 1
  # pop_pre-ws:
  #   - match               : '(?={{ws_beg}})'
  #     pop                 : 1
  # pop_pre-str:
  #   - match               : '(?=\"|r\")'
  #     pop                 :
  # pop2_preâ :
  #   - match               : '(?={{u_sp}})'
  #     pop                 : 2
  # pop2_pre-ch:
  #   - match               : '(?=\{)'
  #     pop                 : 2
  # pop2_pre-term:
  #   - match               : '(?={{node_term_beg}})'
  #     pop                 : 2
  # pop3_pre-term:
  #   - match               : '(?={{node_term_beg}})'
  #     pop                 : 3
  # pop2_preâ¤:
  #   - match               : '(?={{nl_s}})'
  #     pop                 : 2
  # pop2_pre-nodeâ :
  #   - match               : '(?={{node_sp_beg}})'
  #     pop                 : 2
  # pop2_pre-str:
  #   - match               : '(?=\"|r\")'
  #     pop                 : 2
  # pop2_preğŸ†”Â¬:
  #   - match               : '(?={{charID_not}})'
  #     pop                 : 2
  # pop2_pre-ws:
  #   - match               : '(?={{ws_beg}})'
  #     pop                 : 2
  # pop3_pre-str:
  #   - match               : '(?=\"|r\")'
  #     pop                 : 3
  # pop_preï¼‰:
  #   - match               : (?=\))
  #     pop                 : 1
  # pop2_preï¼‰:
  #   - match               : (?=\))
  #     pop                 : 2

  # else-pop:               # pop_pre-non_ws
  #   - match               : '(?=\S)'
  #     pop                 : 1
  # else-pop2:
  #   - match               : '(?=\S)'
  #     pop                 : 2
  # else-pop3:
  #   - match               : '(?=\S)'
  #     pop                 : 3
  # pop:
  #   - match               : ''
  #     pop                 : 1
  # pop2:
  #   - match               : ''
  #     pop                 : 2
  # pop3:
  #   - match               : ''
  #     pop                 : 3
  # pop4:
  #   - match               : ''
  #     pop                 : 4
  # pop5:
  #   - match               : ''
  #     pop                 : 5
  # popâ¸™:
  #   - include             : pop
  # pop2â¸™:
  #   - include             : pop2
  # pop3â¸™:
  #   - include             : pop3
